<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="" name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{display:inline;font-size:34px;}h2.project-version{display:inline;margin-left:10px;margin-top:0;font-size:18px;}.toc-link{margin-left:10px;color:#252519;font-size:12px;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{margin:0;font-size:34px;}.docs-header{margin-bottom:25px;padding-bottom:10px;border-bottom:dotted #aaa 1px;}.toc h1{font-size:24px;}.toc{margin-bottom:40px;border-bottom:solid #bbb 1px;}.toc ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.toc li{padding-left:0;list-style-type:none;}.dependencies{}.dependencies table{border:none;width:99.99%;margin-left:20px;font-size:16px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.plugins li{padding-left:0;list-style-type:none;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;text-align:right;overflow:hidden;top:10px;right:20px;height:20px;}#floating-toc li{margin:0;padding:0;list-style-type:none;}</style><style type="text/css">body{margin:0;padding:0;color:#252519;font-size:16px;background-color:#F5F5FF;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;}h1{margin-top:0;font-size:20px;}a.anchor{color:#252519;text-decoration:none;}a.anchor:hover{color:#5050A6;}table{margin-bottom:10px;border-bottom:solid #ddd 1px;;border-spacing:0;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{border:none;margin:0px;padding-left:55px;width:410px;padding-right:20px;vertical-align:top;max-width:410px;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;background-color:ghostWhite;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
(function(E,B){function ka(a,b,d){if(d===B&&a.nodeType===1){d=a.getAttribute("data-"+b);if(typeof d==="string"){try{d=d==="true"?true:d==="false"?false:d==="null"?null:!c.isNaN(d)?parseFloat(d):Ja.test(d)?c.parseJSON(d):d}catch(e){}c.data(a,b,d)}else d=B}return d}function U(){return false}function ca(){return true}function la(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function Ka(a){var b,d,e,f,h,l,k,o,x,r,A,C=[];f=[];h=c.data(this,this.nodeType?"events":"__events__");if(typeof h==="function")h=
h.events;if(!(a.liveFired===this||!h||!h.live||a.button&&a.type==="click")){if(a.namespace)A=RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)");a.liveFired=this;var J=h.live.slice(0);for(k=0;k<J.length;k++){h=J[k];h.origType.replace(X,"")===a.type?f.push(h.selector):J.splice(k--,1)}f=c(a.target).closest(f,a.currentTarget);o=0;for(x=f.length;o<x;o++){r=f[o];for(k=0;k<J.length;k++){h=J[k];if(r.selector===h.selector&&(!A||A.test(h.namespace))){l=r.elem;e=null;if(h.preType==="mouseenter"||
h.preType==="mouseleave"){a.type=h.preType;e=c(a.relatedTarget).closest(h.selector)[0]}if(!e||e!==l)C.push({elem:l,handleObj:h,level:r.level})}}}o=0;for(x=C.length;o<x;o++){f=C[o];if(d&&f.level>d)break;a.currentTarget=f.elem;a.data=f.handleObj.data;a.handleObj=f.handleObj;A=f.handleObj.origHandler.apply(f.elem,arguments);if(A===false||a.isPropagationStopped()){d=f.level;if(A===false)b=false;if(a.isImmediatePropagationStopped())break}}return b}}function Y(a,b){return(a&&a!=="*"?a+".":"")+b.replace(La,
"`").replace(Ma,"&")}function ma(a,b,d){if(c.isFunction(b))return c.grep(a,function(f,h){return!!b.call(f,h,f)===d});else if(b.nodeType)return c.grep(a,function(f){return f===b===d});else if(typeof b==="string"){var e=c.grep(a,function(f){return f.nodeType===1});if(Na.test(b))return c.filter(b,e,!d);else b=c.filter(b,e)}return c.grep(a,function(f){return c.inArray(f,b)>=0===d})}function na(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var e=c.data(a[d++]),f=c.data(this,
e);if(e=e&&e.events){delete f.handle;f.events={};for(var h in e)for(var l in e[h])c.event.add(this,h,e[h][l],e[h][l].data)}}})}function Oa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function oa(a,b,d){var e=b==="width"?a.offsetWidth:a.offsetHeight;if(d==="border")return e;c.each(b==="width"?Pa:Qa,function(){d||(e-=parseFloat(c.css(a,"padding"+this))||0);if(d==="margin")e+=parseFloat(c.css(a,
"margin"+this))||0;else e-=parseFloat(c.css(a,"border"+this+"Width"))||0});return e}function da(a,b,d,e){if(c.isArray(b)&&b.length)c.each(b,function(f,h){d||Ra.test(a)?e(a,h):da(a+"["+(typeof h==="object"||c.isArray(h)?f:"")+"]",h,d,e)});else if(!d&&b!=null&&typeof b==="object")c.isEmptyObject(b)?e(a,""):c.each(b,function(f,h){da(a+"["+f+"]",h,d,e)});else e(a,b)}function S(a,b){var d={};c.each(pa.concat.apply([],pa.slice(0,b)),function(){d[this]=a});return d}function qa(a){if(!ea[a]){var b=c("<"+
a+">").appendTo("body"),d=b.css("display");b.remove();if(d==="none"||d==="")d="block";ea[a]=d}return ea[a]}function fa(a){return c.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var t=E.document,c=function(){function a(){if(!b.isReady){try{t.documentElement.doScroll("left")}catch(j){setTimeout(a,1);return}b.ready()}}var b=function(j,s){return new b.fn.init(j,s)},d=E.jQuery,e=E.$,f,h=/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,l=/\S/,k=/^\s+/,o=/\s+$/,x=/\W/,r=/\d/,A=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,
C=/^[\],:{}\s]*$/,J=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,w=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,I=/(?:^|:|,)(?:\s*\[)+/g,L=/(webkit)[ \/]([\w.]+)/,g=/(opera)(?:.*version)?[ \/]([\w.]+)/,i=/(msie) ([\w.]+)/,n=/(mozilla)(?:.*? rv:([\w.]+))?/,m=navigator.userAgent,p=false,q=[],u,y=Object.prototype.toString,F=Object.prototype.hasOwnProperty,M=Array.prototype.push,N=Array.prototype.slice,O=String.prototype.trim,D=Array.prototype.indexOf,R={};b.fn=b.prototype={init:function(j,
s){var v,z,H;if(!j)return this;if(j.nodeType){this.context=this[0]=j;this.length=1;return this}if(j==="body"&&!s&&t.body){this.context=t;this[0]=t.body;this.selector="body";this.length=1;return this}if(typeof j==="string")if((v=h.exec(j))&&(v[1]||!s))if(v[1]){H=s?s.ownerDocument||s:t;if(z=A.exec(j))if(b.isPlainObject(s)){j=[t.createElement(z[1])];b.fn.attr.call(j,s,true)}else j=[H.createElement(z[1])];else{z=b.buildFragment([v[1]],[H]);j=(z.cacheable?z.fragment.cloneNode(true):z.fragment).childNodes}return b.merge(this,
j)}else{if((z=t.getElementById(v[2]))&&z.parentNode){if(z.id!==v[2])return f.find(j);this.length=1;this[0]=z}this.context=t;this.selector=j;return this}else if(!s&&!x.test(j)){this.selector=j;this.context=t;j=t.getElementsByTagName(j);return b.merge(this,j)}else return!s||s.jquery?(s||f).find(j):b(s).find(j);else if(b.isFunction(j))return f.ready(j);if(j.selector!==B){this.selector=j.selector;this.context=j.context}return b.makeArray(j,this)},selector:"",jquery:"1.4.4",length:0,size:function(){return this.length},
toArray:function(){return N.call(this,0)},get:function(j){return j==null?this.toArray():j<0?this.slice(j)[0]:this[j]},pushStack:function(j,s,v){var z=b();b.isArray(j)?M.apply(z,j):b.merge(z,j);z.prevObject=this;z.context=this.context;if(s==="find")z.selector=this.selector+(this.selector?" ":"")+v;else if(s)z.selector=this.selector+"."+s+"("+v+")";return z},each:function(j,s){return b.each(this,j,s)},ready:function(j){b.bindReady();if(b.isReady)j.call(t,b);else q&&q.push(j);return this},eq:function(j){return j===
-1?this.slice(j):this.slice(j,+j+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(N.apply(this,arguments),"slice",N.call(arguments).join(","))},map:function(j){return this.pushStack(b.map(this,function(s,v){return j.call(s,v,s)}))},end:function(){return this.prevObject||b(null)},push:M,sort:[].sort,splice:[].splice};b.fn.init.prototype=b.fn;b.extend=b.fn.extend=function(){var j,s,v,z,H,G=arguments[0]||{},K=1,Q=arguments.length,ga=false;
if(typeof G==="boolean"){ga=G;G=arguments[1]||{};K=2}if(typeof G!=="object"&&!b.isFunction(G))G={};if(Q===K){G=this;--K}for(;K<Q;K++)if((j=arguments[K])!=null)for(s in j){v=G[s];z=j[s];if(G!==z)if(ga&&z&&(b.isPlainObject(z)||(H=b.isArray(z)))){if(H){H=false;v=v&&b.isArray(v)?v:[]}else v=v&&b.isPlainObject(v)?v:{};G[s]=b.extend(ga,v,z)}else if(z!==B)G[s]=z}return G};b.extend({noConflict:function(j){E.$=e;if(j)E.jQuery=d;return b},isReady:false,readyWait:1,ready:function(j){j===true&&b.readyWait--;
if(!b.readyWait||j!==true&&!b.isReady){if(!t.body)return setTimeout(b.ready,1);b.isReady=true;if(!(j!==true&&--b.readyWait>0))if(q){var s=0,v=q;for(q=null;j=v[s++];)j.call(t,b);b.fn.trigger&&b(t).trigger("ready").unbind("ready")}}},bindReady:function(){if(!p){p=true;if(t.readyState==="complete")return setTimeout(b.ready,1);if(t.addEventListener){t.addEventListener("DOMContentLoaded",u,false);E.addEventListener("load",b.ready,false)}else if(t.attachEvent){t.attachEvent("onreadystatechange",u);E.attachEvent("onload",
b.ready);var j=false;try{j=E.frameElement==null}catch(s){}t.documentElement.doScroll&&j&&a()}}},isFunction:function(j){return b.type(j)==="function"},isArray:Array.isArray||function(j){return b.type(j)==="array"},isWindow:function(j){return j&&typeof j==="object"&&"setInterval"in j},isNaN:function(j){return j==null||!r.test(j)||isNaN(j)},type:function(j){return j==null?String(j):R[y.call(j)]||"object"},isPlainObject:function(j){if(!j||b.type(j)!=="object"||j.nodeType||b.isWindow(j))return false;if(j.constructor&&
!F.call(j,"constructor")&&!F.call(j.constructor.prototype,"isPrototypeOf"))return false;for(var s in j);return s===B||F.call(j,s)},isEmptyObject:function(j){for(var s in j)return false;return true},error:function(j){throw j;},parseJSON:function(j){if(typeof j!=="string"||!j)return null;j=b.trim(j);if(C.test(j.replace(J,"@").replace(w,"]").replace(I,"")))return E.JSON&&E.JSON.parse?E.JSON.parse(j):(new Function("return "+j))();else b.error("Invalid JSON: "+j)},noop:function(){},globalEval:function(j){if(j&&
l.test(j)){var s=t.getElementsByTagName("head")[0]||t.documentElement,v=t.createElement("script");v.type="text/javascript";if(b.support.scriptEval)v.appendChild(t.createTextNode(j));else v.text=j;s.insertBefore(v,s.firstChild);s.removeChild(v)}},nodeName:function(j,s){return j.nodeName&&j.nodeName.toUpperCase()===s.toUpperCase()},each:function(j,s,v){var z,H=0,G=j.length,K=G===B||b.isFunction(j);if(v)if(K)for(z in j){if(s.apply(j[z],v)===false)break}else for(;H<G;){if(s.apply(j[H++],v)===false)break}else if(K)for(z in j){if(s.call(j[z],
z,j[z])===false)break}else for(v=j[0];H<G&&s.call(v,H,v)!==false;v=j[++H]);return j},trim:O?function(j){return j==null?"":O.call(j)}:function(j){return j==null?"":j.toString().replace(k,"").replace(o,"")},makeArray:function(j,s){var v=s||[];if(j!=null){var z=b.type(j);j.length==null||z==="string"||z==="function"||z==="regexp"||b.isWindow(j)?M.call(v,j):b.merge(v,j)}return v},inArray:function(j,s){if(s.indexOf)return s.indexOf(j);for(var v=0,z=s.length;v<z;v++)if(s[v]===j)return v;return-1},merge:function(j,
s){var v=j.length,z=0;if(typeof s.length==="number")for(var H=s.length;z<H;z++)j[v++]=s[z];else for(;s[z]!==B;)j[v++]=s[z++];j.length=v;return j},grep:function(j,s,v){var z=[],H;v=!!v;for(var G=0,K=j.length;G<K;G++){H=!!s(j[G],G);v!==H&&z.push(j[G])}return z},map:function(j,s,v){for(var z=[],H,G=0,K=j.length;G<K;G++){H=s(j[G],G,v);if(H!=null)z[z.length]=H}return z.concat.apply([],z)},guid:1,proxy:function(j,s,v){if(arguments.length===2)if(typeof s==="string"){v=j;j=v[s];s=B}else if(s&&!b.isFunction(s)){v=
s;s=B}if(!s&&j)s=function(){return j.apply(v||this,arguments)};if(j)s.guid=j.guid=j.guid||s.guid||b.guid++;return s},access:function(j,s,v,z,H,G){var K=j.length;if(typeof s==="object"){for(var Q in s)b.access(j,Q,s[Q],z,H,v);return j}if(v!==B){z=!G&&z&&b.isFunction(v);for(Q=0;Q<K;Q++)H(j[Q],s,z?v.call(j[Q],Q,H(j[Q],s)):v,G);return j}return K?H(j[0],s):B},now:function(){return(new Date).getTime()},uaMatch:function(j){j=j.toLowerCase();j=L.exec(j)||g.exec(j)||i.exec(j)||j.indexOf("compatible")<0&&n.exec(j)||
[];return{browser:j[1]||"",version:j[2]||"0"}},browser:{}});b.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(j,s){R["[object "+s+"]"]=s.toLowerCase()});m=b.uaMatch(m);if(m.browser){b.browser[m.browser]=true;b.browser.version=m.version}if(b.browser.webkit)b.browser.safari=true;if(D)b.inArray=function(j,s){return D.call(s,j)};if(!/\s/.test("\u00a0")){k=/^[\s\xA0]+/;o=/[\s\xA0]+$/}f=b(t);if(t.addEventListener)u=function(){t.removeEventListener("DOMContentLoaded",u,
false);b.ready()};else if(t.attachEvent)u=function(){if(t.readyState==="complete"){t.detachEvent("onreadystatechange",u);b.ready()}};return E.jQuery=E.$=b}();(function(){c.support={};var a=t.documentElement,b=t.createElement("script"),d=t.createElement("div"),e="script"+c.now();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var f=d.getElementsByTagName("*"),h=d.getElementsByTagName("a")[0],l=t.createElement("select"),
k=l.appendChild(t.createElement("option"));if(!(!f||!f.length||!h)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(h.getAttribute("style")),hrefNormalized:h.getAttribute("href")==="/a",opacity:/^0.55$/.test(h.style.opacity),cssFloat:!!h.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:k.selected,deleteExpando:true,optDisabled:false,checkClone:false,
scriptEval:false,noCloneEvent:true,boxModel:null,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableHiddenOffsets:true};l.disabled=true;c.support.optDisabled=!k.disabled;b.type="text/javascript";try{b.appendChild(t.createTextNode("window."+e+"=1;"))}catch(o){}a.insertBefore(b,a.firstChild);if(E[e]){c.support.scriptEval=true;delete E[e]}try{delete b.test}catch(x){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function r(){c.support.noCloneEvent=
false;d.detachEvent("onclick",r)});d.cloneNode(true).fireEvent("onclick")}d=t.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=t.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var r=t.createElement("div");r.style.width=r.style.paddingLeft="1px";t.body.appendChild(r);c.boxModel=c.support.boxModel=r.offsetWidth===2;if("zoom"in r.style){r.style.display="inline";r.style.zoom=
1;c.support.inlineBlockNeedsLayout=r.offsetWidth===2;r.style.display="";r.innerHTML="<div style='width:4px;'></div>";c.support.shrinkWrapBlocks=r.offsetWidth!==2}r.innerHTML="<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";var A=r.getElementsByTagName("td");c.support.reliableHiddenOffsets=A[0].offsetHeight===0;A[0].style.display="";A[1].style.display="none";c.support.reliableHiddenOffsets=c.support.reliableHiddenOffsets&&A[0].offsetHeight===0;r.innerHTML="";t.body.removeChild(r).style.display=
"none"});a=function(r){var A=t.createElement("div");r="on"+r;var C=r in A;if(!C){A.setAttribute(r,"return;");C=typeof A[r]==="function"}return C};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=f=h=null}})();var ra={},Ja=/^(?:\{.*\}|\[.*\])$/;c.extend({cache:{},uuid:0,expando:"jQuery"+c.now(),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},data:function(a,b,d){if(c.acceptData(a)){a=a==E?ra:a;var e=a.nodeType,f=e?a[c.expando]:null,h=
c.cache;if(!(e&&!f&&typeof b==="string"&&d===B)){if(e)f||(a[c.expando]=f=++c.uuid);else h=a;if(typeof b==="object")if(e)h[f]=c.extend(h[f],b);else c.extend(h,b);else if(e&&!h[f])h[f]={};a=e?h[f]:h;if(d!==B)a[b]=d;return typeof b==="string"?a[b]:a}}},removeData:function(a,b){if(c.acceptData(a)){a=a==E?ra:a;var d=a.nodeType,e=d?a[c.expando]:a,f=c.cache,h=d?f[e]:e;if(b){if(h){delete h[b];d&&c.isEmptyObject(h)&&c.removeData(a)}}else if(d&&c.support.deleteExpando)delete a[c.expando];else if(a.removeAttribute)a.removeAttribute(c.expando);
else if(d)delete f[e];else for(var l in a)delete a[l]}},acceptData:function(a){if(a.nodeName){var b=c.noData[a.nodeName.toLowerCase()];if(b)return!(b===true||a.getAttribute("classid")!==b)}return true}});c.fn.extend({data:function(a,b){var d=null;if(typeof a==="undefined"){if(this.length){var e=this[0].attributes,f;d=c.data(this[0]);for(var h=0,l=e.length;h<l;h++){f=e[h].name;if(f.indexOf("data-")===0){f=f.substr(5);ka(this[0],f,d[f])}}}return d}else if(typeof a==="object")return this.each(function(){c.data(this,
a)});var k=a.split(".");k[1]=k[1]?"."+k[1]:"";if(b===B){d=this.triggerHandler("getData"+k[1]+"!",[k[0]]);if(d===B&&this.length){d=c.data(this[0],a);d=ka(this[0],a,d)}return d===B&&k[1]?this.data(k[0]):d}else return this.each(function(){var o=c(this),x=[k[0],b];o.triggerHandler("setData"+k[1]+"!",x);c.data(this,a,b);o.triggerHandler("changeData"+k[1]+"!",x)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var e=
c.data(a,b);if(!d)return e||[];if(!e||c.isArray(d))e=c.data(a,b,c.makeArray(d));else e.push(d);return e}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),e=d.shift();if(e==="inprogress")e=d.shift();if(e){b==="fx"&&d.unshift("inprogress");e.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===B)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,
a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var sa=/[\n\t]/g,ha=/\s+/,Sa=/\r/g,Ta=/^(?:href|src|style)$/,Ua=/^(?:button|input)$/i,Va=/^(?:button|input|object|select|textarea)$/i,Wa=/^a(?:rea)?$/i,ta=/^(?:radio|checkbox)$/i;c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",
colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};c.fn.extend({attr:function(a,b){return c.access(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(x){var r=c(this);r.addClass(a.call(this,x,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===
1)if(f.className){for(var h=" "+f.className+" ",l=f.className,k=0,o=b.length;k<o;k++)if(h.indexOf(" "+b[k]+" ")<0)l+=" "+b[k];f.className=c.trim(l)}else f.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(o){var x=c(this);x.removeClass(a.call(this,o,x.attr("class")))});if(a&&typeof a==="string"||a===B)for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===1&&f.className)if(a){for(var h=(" "+f.className+" ").replace(sa," "),
l=0,k=b.length;l<k;l++)h=h.replace(" "+b[l]+" "," ");f.className=c.trim(h)}else f.className=""}return this},toggleClass:function(a,b){var d=typeof a,e=typeof b==="boolean";if(c.isFunction(a))return this.each(function(f){var h=c(this);h.toggleClass(a.call(this,f,h.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var f,h=0,l=c(this),k=b,o=a.split(ha);f=o[h++];){k=e?k:!l.hasClass(f);l[k?"addClass":"removeClass"](f)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,
"__className__",this.className);this.className=this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(sa," ").indexOf(a)>-1)return true;return false},val:function(a){if(!arguments.length){var b=this[0];if(b){if(c.nodeName(b,"option")){var d=b.attributes.value;return!d||d.specified?b.value:b.text}if(c.nodeName(b,"select")){var e=b.selectedIndex;d=[];var f=b.options;b=b.type==="select-one";
if(e<0)return null;var h=b?e:0;for(e=b?e+1:f.length;h<e;h++){var l=f[h];if(l.selected&&(c.support.optDisabled?!l.disabled:l.getAttribute("disabled")===null)&&(!l.parentNode.disabled||!c.nodeName(l.parentNode,"optgroup"))){a=c(l).val();if(b)return a;d.push(a)}}return d}if(ta.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Sa,"")}return B}var k=c.isFunction(a);return this.each(function(o){var x=c(this),r=a;if(this.nodeType===1){if(k)r=
a.call(this,o,x.val());if(r==null)r="";else if(typeof r==="number")r+="";else if(c.isArray(r))r=c.map(r,function(C){return C==null?"":C+""});if(c.isArray(r)&&ta.test(this.type))this.checked=c.inArray(x.val(),r)>=0;else if(c.nodeName(this,"select")){var A=c.makeArray(r);c("option",this).each(function(){this.selected=c.inArray(c(this).val(),A)>=0});if(!A.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},
attr:function(a,b,d,e){if(!a||a.nodeType===3||a.nodeType===8)return B;if(e&&b in c.attrFn)return c(a)[b](d);e=a.nodeType!==1||!c.isXMLDoc(a);var f=d!==B;b=e&&c.props[b]||b;var h=Ta.test(b);if((b in a||a[b]!==B)&&e&&!h){if(f){b==="type"&&Ua.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");if(d===null)a.nodeType===1&&a.removeAttribute(b);else a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&
b.specified?b.value:Va.test(a.nodeName)||Wa.test(a.nodeName)&&a.href?0:B;return a[b]}if(!c.support.style&&e&&b==="style"){if(f)a.style.cssText=""+d;return a.style.cssText}f&&a.setAttribute(b,""+d);if(!a.attributes[b]&&a.hasAttribute&&!a.hasAttribute(b))return B;a=!c.support.hrefNormalized&&e&&h?a.getAttribute(b,2):a.getAttribute(b);return a===null?B:a}});var X=/\.(.*)$/,ia=/^(?:textarea|input|select)$/i,La=/\./g,Ma=/ /g,Xa=/[^\w\s.|`]/g,Ya=function(a){return a.replace(Xa,"\\$&")},ua={focusin:0,focusout:0};
c.event={add:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(c.isWindow(a)&&a!==E&&!a.frameElement)a=E;if(d===false)d=U;else if(!d)return;var f,h;if(d.handler){f=d;d=f.handler}if(!d.guid)d.guid=c.guid++;if(h=c.data(a)){var l=a.nodeType?"events":"__events__",k=h[l],o=h.handle;if(typeof k==="function"){o=k.handle;k=k.events}else if(!k){a.nodeType||(h[l]=h=function(){});h.events=k={}}if(!o)h.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,
arguments):B};o.elem=a;b=b.split(" ");for(var x=0,r;l=b[x++];){h=f?c.extend({},f):{handler:d,data:e};if(l.indexOf(".")>-1){r=l.split(".");l=r.shift();h.namespace=r.slice(0).sort().join(".")}else{r=[];h.namespace=""}h.type=l;if(!h.guid)h.guid=d.guid;var A=k[l],C=c.event.special[l]||{};if(!A){A=k[l]=[];if(!C.setup||C.setup.call(a,e,r,o)===false)if(a.addEventListener)a.addEventListener(l,o,false);else a.attachEvent&&a.attachEvent("on"+l,o)}if(C.add){C.add.call(a,h);if(!h.handler.guid)h.handler.guid=
d.guid}A.push(h);c.event.global[l]=true}a=null}}},global:{},remove:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(d===false)d=U;var f,h,l=0,k,o,x,r,A,C,J=a.nodeType?"events":"__events__",w=c.data(a),I=w&&w[J];if(w&&I){if(typeof I==="function"){w=I;I=I.events}if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(f in I)c.event.remove(a,f+b)}else{for(b=b.split(" ");f=b[l++];){r=f;k=f.indexOf(".")<0;o=[];if(!k){o=f.split(".");f=o.shift();x=RegExp("(^|\\.)"+
c.map(o.slice(0).sort(),Ya).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(A=I[f])if(d){r=c.event.special[f]||{};for(h=e||0;h<A.length;h++){C=A[h];if(d.guid===C.guid){if(k||x.test(C.namespace)){e==null&&A.splice(h--,1);r.remove&&r.remove.call(a,C)}if(e!=null)break}}if(A.length===0||e!=null&&A.length===1){if(!r.teardown||r.teardown.call(a,o)===false)c.removeEvent(a,f,w.handle);delete I[f]}}else for(h=0;h<A.length;h++){C=A[h];if(k||x.test(C.namespace)){c.event.remove(a,r,C.handler,h);A.splice(h--,1)}}}if(c.isEmptyObject(I)){if(b=
w.handle)b.elem=null;delete w.events;delete w.handle;if(typeof w==="function")c.removeData(a,J);else c.isEmptyObject(w)&&c.removeData(a)}}}}},trigger:function(a,b,d,e){var f=a.type||a;if(!e){a=typeof a==="object"?a[c.expando]?a:c.extend(c.Event(f),a):c.Event(f);if(f.indexOf("!")>=0){a.type=f=f.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[f]&&c.each(c.cache,function(){this.events&&this.events[f]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===
8)return B;a.result=B;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(e=d.nodeType?c.data(d,"handle"):(c.data(d,"__events__")||{}).handle)&&e.apply(d,b);e=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+f]&&d["on"+f].apply(d,b)===false){a.result=false;a.preventDefault()}}catch(h){}if(!a.isPropagationStopped()&&e)c.event.trigger(a,b,e,true);else if(!a.isDefaultPrevented()){var l;e=a.target;var k=f.replace(X,""),o=c.nodeName(e,"a")&&k===
"click",x=c.event.special[k]||{};if((!x._default||x._default.call(d,a)===false)&&!o&&!(e&&e.nodeName&&c.noData[e.nodeName.toLowerCase()])){try{if(e[k]){if(l=e["on"+k])e["on"+k]=null;c.event.triggered=true;e[k]()}}catch(r){}if(l)e["on"+k]=l;c.event.triggered=false}}},handle:function(a){var b,d,e,f;d=[];var h=c.makeArray(arguments);a=h[0]=c.event.fix(a||E.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;if(!b){e=a.type.split(".");a.type=e.shift();d=e.slice(0).sort();e=RegExp("(^|\\.)"+
d.join("\\.(?:.*\\.)?")+"(\\.|$)")}a.namespace=a.namespace||d.join(".");f=c.data(this,this.nodeType?"events":"__events__");if(typeof f==="function")f=f.events;d=(f||{})[a.type];if(f&&d){d=d.slice(0);f=0;for(var l=d.length;f<l;f++){var k=d[f];if(b||e.test(k.namespace)){a.handler=k.handler;a.data=k.data;a.handleObj=k;k=k.handler.apply(this,h);if(k!==B){a.result=k;if(k===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[c.expando])return a;var b=a;a=c.Event(b);for(var d=this.props.length,e;d;){e=this.props[--d];a[e]=b[e]}if(!a.target)a.target=a.srcElement||t;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=t.documentElement;d=t.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(a.which==null&&(a.charCode!=null||a.keyCode!=null))a.which=a.charCode!=null?a.charCode:a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==B)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,Y(a.origType,a.selector),c.extend({},a,{handler:Ka,guid:a.handler.guid}))},remove:function(a){c.event.remove(this,
Y(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,d){if(c.isWindow(this))this.onbeforeunload=d},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};c.removeEvent=t.removeEventListener?function(a,b,d){a.removeEventListener&&a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent&&a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=
c.now();this[c.expando]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=ca;var a=this.originalEvent;if(a)if(a.preventDefault)a.preventDefault();else a.returnValue=false},stopPropagation:function(){this.isPropagationStopped=ca;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ca;this.stopPropagation()},isDefaultPrevented:U,isPropagationStopped:U,isImmediatePropagationStopped:U};
var va=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},wa=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?wa:va,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?wa:va)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==
"form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length){a.liveFired=B;return la("submit",this,arguments)}});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13){a.liveFired=B;return la("submit",this,arguments)}})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};if(!c.support.changeBubbles){var V,
xa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(e){return e.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},Z=function(a,b){var d=a.target,e,f;if(!(!ia.test(d.nodeName)||d.readOnly)){e=c.data(d,"_change_data");f=xa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",f);if(!(e===B||f===e))if(e!=null||f){a.type="change";a.liveFired=
B;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:Z,beforedeactivate:Z,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return Z.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return Z.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,"_change_data",xa(a))}},setup:function(){if(this.type===
"file")return false;for(var a in V)c.event.add(this,a+".specialChange",V[a]);return ia.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return ia.test(this.nodeName)}};V=c.event.special.change.filters;V.focus=V.beforeactivate}t.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.trigger(e,null,e.target)}c.event.special[b]={setup:function(){ua[b]++===0&&t.addEventListener(a,d,true)},teardown:function(){--ua[b]===
0&&t.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,e,f){if(typeof d==="object"){for(var h in d)this[b](h,e,d[h],f);return this}if(c.isFunction(e)||e===false){f=e;e=B}var l=b==="one"?c.proxy(f,function(o){c(this).unbind(o,l);return f.apply(this,arguments)}):f;if(d==="unload"&&b!=="one")this.one(d,e,f);else{h=0;for(var k=this.length;h<k;h++)c.event.add(this[h],d,l,e)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&!a.preventDefault)for(var d in a)this.unbind(d,
a[d]);else{d=0;for(var e=this.length;d<e;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,e){return this.live(b,d,e,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){var d=c.Event(a);d.preventDefault();d.stopPropagation();c.event.trigger(d,b,this[0]);return d.result}},toggle:function(a){for(var b=arguments,d=
1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(e){var f=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,f+1);e.preventDefault();return b[f].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var ya={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,e,f,h){var l,k=0,o,x,r=h||this.selector;h=h?this:c(this.context);if(typeof d===
"object"&&!d.preventDefault){for(l in d)h[b](l,e,d[l],r);return this}if(c.isFunction(e)){f=e;e=B}for(d=(d||"").split(" ");(l=d[k++])!=null;){o=X.exec(l);x="";if(o){x=o[0];l=l.replace(X,"")}if(l==="hover")d.push("mouseenter"+x,"mouseleave"+x);else{o=l;if(l==="focus"||l==="blur"){d.push(ya[l]+x);l+=x}else l=(ya[l]||l)+x;if(b==="live"){x=0;for(var A=h.length;x<A;x++)c.event.add(h[x],"live."+Y(l,r),{data:e,selector:r,handler:f,origType:l,origHandler:f,preType:o})}else h.unbind("live."+Y(l,r),f)}}return this}});
c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){c.fn[b]=function(d,e){if(e==null){e=d;d=null}return arguments.length>0?this.bind(b,d,e):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});E.attachEvent&&!E.addEventListener&&c(E).bind("unload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});
(function(){function a(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1&&!q){y.sizcache=n;y.sizset=p}if(y.nodeName.toLowerCase()===i){F=y;break}y=y[g]}m[p]=F}}}function b(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1){if(!q){y.sizcache=n;y.sizset=p}if(typeof i!=="string"){if(y===i){F=true;break}}else if(k.filter(i,
[y]).length>0){F=y;break}}y=y[g]}m[p]=F}}}var d=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,f=Object.prototype.toString,h=false,l=true;[0,0].sort(function(){l=false;return 0});var k=function(g,i,n,m){n=n||[];var p=i=i||t;if(i.nodeType!==1&&i.nodeType!==9)return[];if(!g||typeof g!=="string")return n;var q,u,y,F,M,N=true,O=k.isXML(i),D=[],R=g;do{d.exec("");if(q=d.exec(R)){R=q[3];D.push(q[1]);if(q[2]){F=q[3];
break}}}while(q);if(D.length>1&&x.exec(g))if(D.length===2&&o.relative[D[0]])u=L(D[0]+D[1],i);else for(u=o.relative[D[0]]?[i]:k(D.shift(),i);D.length;){g=D.shift();if(o.relative[g])g+=D.shift();u=L(g,u)}else{if(!m&&D.length>1&&i.nodeType===9&&!O&&o.match.ID.test(D[0])&&!o.match.ID.test(D[D.length-1])){q=k.find(D.shift(),i,O);i=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]}if(i){q=m?{expr:D.pop(),set:C(m)}:k.find(D.pop(),D.length===1&&(D[0]==="~"||D[0]==="+")&&i.parentNode?i.parentNode:i,O);u=q.expr?k.filter(q.expr,
q.set):q.set;if(D.length>0)y=C(u);else N=false;for(;D.length;){q=M=D.pop();if(o.relative[M])q=D.pop();else M="";if(q==null)q=i;o.relative[M](y,q,O)}}else y=[]}y||(y=u);y||k.error(M||g);if(f.call(y)==="[object Array]")if(N)if(i&&i.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&k.contains(i,y[g])))n.push(u[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&n.push(u[g]);else n.push.apply(n,y);else C(y,n);if(F){k(F,p,n,m);k.uniqueSort(n)}return n};k.uniqueSort=function(g){if(w){h=
l;g.sort(w);if(h)for(var i=1;i<g.length;i++)g[i]===g[i-1]&&g.splice(i--,1)}return g};k.matches=function(g,i){return k(g,null,null,i)};k.matchesSelector=function(g,i){return k(i,null,null,[g]).length>0};k.find=function(g,i,n){var m;if(!g)return[];for(var p=0,q=o.order.length;p<q;p++){var u,y=o.order[p];if(u=o.leftMatch[y].exec(g)){var F=u[1];u.splice(1,1);if(F.substr(F.length-1)!=="\\"){u[1]=(u[1]||"").replace(/\\/g,"");m=o.find[y](u,i,n);if(m!=null){g=g.replace(o.match[y],"");break}}}}m||(m=i.getElementsByTagName("*"));
return{set:m,expr:g}};k.filter=function(g,i,n,m){for(var p,q,u=g,y=[],F=i,M=i&&i[0]&&k.isXML(i[0]);g&&i.length;){for(var N in o.filter)if((p=o.leftMatch[N].exec(g))!=null&&p[2]){var O,D,R=o.filter[N];D=p[1];q=false;p.splice(1,1);if(D.substr(D.length-1)!=="\\"){if(F===y)y=[];if(o.preFilter[N])if(p=o.preFilter[N](p,F,n,y,m,M)){if(p===true)continue}else q=O=true;if(p)for(var j=0;(D=F[j])!=null;j++)if(D){O=R(D,p,j,F);var s=m^!!O;if(n&&O!=null)if(s)q=true;else F[j]=false;else if(s){y.push(D);q=true}}if(O!==
B){n||(F=y);g=g.replace(o.match[N],"");if(!q)return[];break}}}if(g===u)if(q==null)k.error(g);else break;u=g}return F};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var o=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},relative:{"+":function(g,i){var n=typeof i==="string",m=n&&!/\W/.test(i);n=n&&!m;if(m)i=i.toLowerCase();m=0;for(var p=g.length,q;m<p;m++)if(q=g[m]){for(;(q=q.previousSibling)&&q.nodeType!==1;);g[m]=n||q&&q.nodeName.toLowerCase()===
i?q||false:q===i}n&&k.filter(i,g,true)},">":function(g,i){var n,m=typeof i==="string",p=0,q=g.length;if(m&&!/\W/.test(i))for(i=i.toLowerCase();p<q;p++){if(n=g[p]){n=n.parentNode;g[p]=n.nodeName.toLowerCase()===i?n:false}}else{for(;p<q;p++)if(n=g[p])g[p]=m?n.parentNode:n.parentNode===i;m&&k.filter(i,g,true)}},"":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=i=i.toLowerCase();q=a}q("parentNode",i,p,g,m,n)},"~":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=
i=i.toLowerCase();q=a}q("previousSibling",i,p,g,m,n)}},find:{ID:function(g,i,n){if(typeof i.getElementById!=="undefined"&&!n)return(g=i.getElementById(g[1]))&&g.parentNode?[g]:[]},NAME:function(g,i){if(typeof i.getElementsByName!=="undefined"){for(var n=[],m=i.getElementsByName(g[1]),p=0,q=m.length;p<q;p++)m[p].getAttribute("name")===g[1]&&n.push(m[p]);return n.length===0?null:n}},TAG:function(g,i){return i.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,i,n,m,p,q){g=" "+g[1].replace(/\\/g,
"")+" ";if(q)return g;q=0;for(var u;(u=i[q])!=null;q++)if(u)if(p^(u.className&&(" "+u.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))n||m.push(u);else if(n)i[q]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]==="nth"){var i=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=i[1]+(i[2]||1)-0;g[3]=i[3]-0}g[0]=e++;return g},ATTR:function(g,i,n,
m,p,q){i=g[1].replace(/\\/g,"");if(!q&&o.attrMap[i])g[1]=o.attrMap[i];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,i,n,m,p){if(g[1]==="not")if((d.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,i);else{g=k.filter(g[3],i,n,true^p);n||m.push.apply(m,g);return false}else if(o.match.POS.test(g[0])||o.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===
true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,i,n){return!!k(n[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===
g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},setFilters:{first:function(g,i){return i===0},last:function(g,i,n,m){return i===m.length-1},even:function(g,i){return i%2===0},odd:function(g,i){return i%2===1},lt:function(g,i,n){return i<n[3]-0},gt:function(g,i,n){return i>n[3]-0},nth:function(g,i,n){return n[3]-
0===i},eq:function(g,i,n){return n[3]-0===i}},filter:{PSEUDO:function(g,i,n,m){var p=i[1],q=o.filters[p];if(q)return q(g,n,i,m);else if(p==="contains")return(g.textContent||g.innerText||k.getText([g])||"").indexOf(i[3])>=0;else if(p==="not"){i=i[3];n=0;for(m=i.length;n<m;n++)if(i[n]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+p)},CHILD:function(g,i){var n=i[1],m=g;switch(n){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(n===
"first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":n=i[2];var p=i[3];if(n===1&&p===0)return true;var q=i[0],u=g.parentNode;if(u&&(u.sizcache!==q||!g.nodeIndex)){var y=0;for(m=u.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++y;u.sizcache=q}m=g.nodeIndex-p;return n===0?m===0:m%n===0&&m/n>=0}},ID:function(g,i){return g.nodeType===1&&g.getAttribute("id")===i},TAG:function(g,i){return i==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===
i},CLASS:function(g,i){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(i)>-1},ATTR:function(g,i){var n=i[1];n=o.attrHandle[n]?o.attrHandle[n](g):g[n]!=null?g[n]:g.getAttribute(n);var m=n+"",p=i[2],q=i[4];return n==null?p==="!=":p==="="?m===q:p==="*="?m.indexOf(q)>=0:p==="~="?(" "+m+" ").indexOf(q)>=0:!q?m&&n!==false:p==="!="?m!==q:p==="^="?m.indexOf(q)===0:p==="$="?m.substr(m.length-q.length)===q:p==="|="?m===q||m.substr(0,q.length+1)===q+"-":false},POS:function(g,i,n,m){var p=o.setFilters[i[2]];
if(p)return p(g,n,i,m)}}},x=o.match.POS,r=function(g,i){return"\\"+(i-0+1)},A;for(A in o.match){o.match[A]=RegExp(o.match[A].source+/(?![^\[]*\])(?![^\(]*\))/.source);o.leftMatch[A]=RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[A].source.replace(/\\(\d+)/g,r))}var C=function(g,i){g=Array.prototype.slice.call(g,0);if(i){i.push.apply(i,g);return i}return g};try{Array.prototype.slice.call(t.documentElement.childNodes,0)}catch(J){C=function(g,i){var n=0,m=i||[];if(f.call(g)==="[object Array]")Array.prototype.push.apply(m,
g);else if(typeof g.length==="number")for(var p=g.length;n<p;n++)m.push(g[n]);else for(;g[n];n++)m.push(g[n]);return m}}var w,I;if(t.documentElement.compareDocumentPosition)w=function(g,i){if(g===i){h=true;return 0}if(!g.compareDocumentPosition||!i.compareDocumentPosition)return g.compareDocumentPosition?-1:1;return g.compareDocumentPosition(i)&4?-1:1};else{w=function(g,i){var n,m,p=[],q=[];n=g.parentNode;m=i.parentNode;var u=n;if(g===i){h=true;return 0}else if(n===m)return I(g,i);else if(n){if(!m)return 1}else return-1;
for(;u;){p.unshift(u);u=u.parentNode}for(u=m;u;){q.unshift(u);u=u.parentNode}n=p.length;m=q.length;for(u=0;u<n&&u<m;u++)if(p[u]!==q[u])return I(p[u],q[u]);return u===n?I(g,q[u],-1):I(p[u],i,1)};I=function(g,i,n){if(g===i)return n;for(g=g.nextSibling;g;){if(g===i)return-1;g=g.nextSibling}return 1}}k.getText=function(g){for(var i="",n,m=0;g[m];m++){n=g[m];if(n.nodeType===3||n.nodeType===4)i+=n.nodeValue;else if(n.nodeType!==8)i+=k.getText(n.childNodes)}return i};(function(){var g=t.createElement("div"),
i="script"+(new Date).getTime(),n=t.documentElement;g.innerHTML="<a name='"+i+"'/>";n.insertBefore(g,n.firstChild);if(t.getElementById(i)){o.find.ID=function(m,p,q){if(typeof p.getElementById!=="undefined"&&!q)return(p=p.getElementById(m[1]))?p.id===m[1]||typeof p.getAttributeNode!=="undefined"&&p.getAttributeNode("id").nodeValue===m[1]?[p]:B:[]};o.filter.ID=function(m,p){var q=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&q&&q.nodeValue===p}}n.removeChild(g);
n=g=null})();(function(){var g=t.createElement("div");g.appendChild(t.createComment(""));if(g.getElementsByTagName("*").length>0)o.find.TAG=function(i,n){var m=n.getElementsByTagName(i[1]);if(i[1]==="*"){for(var p=[],q=0;m[q];q++)m[q].nodeType===1&&p.push(m[q]);m=p}return m};g.innerHTML="<a href='#'></a>";if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")o.attrHandle.href=function(i){return i.getAttribute("href",2)};g=null})();t.querySelectorAll&&
function(){var g=k,i=t.createElement("div");i.innerHTML="<p class='TEST'></p>";if(!(i.querySelectorAll&&i.querySelectorAll(".TEST").length===0)){k=function(m,p,q,u){p=p||t;m=m.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!u&&!k.isXML(p))if(p.nodeType===9)try{return C(p.querySelectorAll(m),q)}catch(y){}else if(p.nodeType===1&&p.nodeName.toLowerCase()!=="object"){var F=p.getAttribute("id"),M=F||"__sizzle__";F||p.setAttribute("id",M);try{return C(p.querySelectorAll("#"+M+" "+m),q)}catch(N){}finally{F||
p.removeAttribute("id")}}return g(m,p,q,u)};for(var n in g)k[n]=g[n];i=null}}();(function(){var g=t.documentElement,i=g.matchesSelector||g.mozMatchesSelector||g.webkitMatchesSelector||g.msMatchesSelector,n=false;try{i.call(t.documentElement,"[test!='']:sizzle")}catch(m){n=true}if(i)k.matchesSelector=function(p,q){q=q.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(p))try{if(n||!o.match.PSEUDO.test(q)&&!/!=/.test(q))return i.call(p,q)}catch(u){}return k(q,null,null,[p]).length>0}})();(function(){var g=
t.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){o.order.splice(1,0,"CLASS");o.find.CLASS=function(i,n,m){if(typeof n.getElementsByClassName!=="undefined"&&!m)return n.getElementsByClassName(i[1])};g=null}}})();k.contains=t.documentElement.contains?function(g,i){return g!==i&&(g.contains?g.contains(i):true)}:t.documentElement.compareDocumentPosition?
function(g,i){return!!(g.compareDocumentPosition(i)&16)}:function(){return false};k.isXML=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false};var L=function(g,i){for(var n,m=[],p="",q=i.nodeType?[i]:i;n=o.match.PSEUDO.exec(g);){p+=n[0];g=g.replace(o.match.PSEUDO,"")}g=o.relative[g]?g+"*":g;n=0;for(var u=q.length;n<u;n++)k(g,q[n],m);return k.filter(p,m)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=k.getText;c.isXMLDoc=k.isXML;
c.contains=k.contains})();var Za=/Until$/,$a=/^(?:parents|prevUntil|prevAll)/,ab=/,/,Na=/^.[^:#\[\.,]*$/,bb=Array.prototype.slice,cb=c.expr.match.POS;c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,e=0,f=this.length;e<f;e++){d=b.length;c.find(a,this[e],b);if(e>0)for(var h=d;h<b.length;h++)for(var l=0;l<d;l++)if(b[l]===b[h]){b.splice(h--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,e=b.length;d<e;d++)if(c.contains(this,b[d]))return true})},
not:function(a){return this.pushStack(ma(this,a,false),"not",a)},filter:function(a){return this.pushStack(ma(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){var d=[],e,f,h=this[0];if(c.isArray(a)){var l,k={},o=1;if(h&&a.length){e=0;for(f=a.length;e<f;e++){l=a[e];k[l]||(k[l]=c.expr.match.POS.test(l)?c(l,b||this.context):l)}for(;h&&h.ownerDocument&&h!==b;){for(l in k){e=k[l];if(e.jquery?e.index(h)>-1:c(h).is(e))d.push({selector:l,elem:h,level:o})}h=
h.parentNode;o++}}return d}l=cb.test(a)?c(a,b||this.context):null;e=0;for(f=this.length;e<f;e++)for(h=this[e];h;)if(l?l.index(h)>-1:c.find.matchesSelector(h,a)){d.push(h);break}else{h=h.parentNode;if(!h||!h.ownerDocument||h===b)break}d=d.length>1?c.unique(d):d;return this.pushStack(d,"closest",a)},index:function(a){if(!a||typeof a==="string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var d=typeof a==="string"?c(a,b||this.context):
c.makeArray(a),e=c.merge(this.get(),d);return this.pushStack(!d[0]||!d[0].parentNode||d[0].parentNode.nodeType===11||!e[0]||!e[0].parentNode||e[0].parentNode.nodeType===11?e:c.unique(e))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,
2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,
b){c.fn[a]=function(d,e){var f=c.map(this,b,d);Za.test(a)||(e=d);if(e&&typeof e==="string")f=c.filter(e,f);f=this.length>1?c.unique(f):f;if((this.length>1||ab.test(e))&&$a.test(a))f=f.reverse();return this.pushStack(f,a,bb.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return b.length===1?c.find.matchesSelector(b[0],a)?[b[0]]:[]:c.find.matches(a,b)},dir:function(a,b,d){var e=[];for(a=a[b];a&&a.nodeType!==9&&(d===B||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&
e.push(a);a=a[b]}return e},nth:function(a,b,d){b=b||1;for(var e=0;a;a=a[d])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var za=/ jQuery\d+="(?:\d+|null)"/g,$=/^\s+/,Aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Ba=/<([\w:]+)/,db=/<tbody/i,eb=/<|&#?\w+;/,Ca=/<(?:script|object|embed|option|style)/i,Da=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/\=([^="'>\s]+\/)>/g,P={option:[1,
"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};P.optgroup=P.option;P.tbody=P.tfoot=P.colgroup=P.caption=P.thead;P.th=P.td;if(!c.support.htmlSerialize)P._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==B)return this.empty().append((this[0]&&this[0].ownerDocument||t).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,e;(e=this[d])!=null;d++)if(!a||c.filter(a,[e]).length){if(!b&&e.nodeType===1){c.cleanData(e.getElementsByTagName("*"));c.cleanData([e])}e.parentNode&&e.parentNode.removeChild(e)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,e=this.ownerDocument;if(!d){d=e.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(za,"").replace(fb,'="$1">').replace($,"")],e)[0]}else return this.cloneNode(true)});if(a===true){na(this,b);na(this.find("*"),b.find("*"))}return b},html:function(a){if(a===B)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(za,""):null;
else if(typeof a==="string"&&!Ca.test(a)&&(c.support.leadingWhitespace||!$.test(a))&&!P[(Ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Aa,"<$1></$2>");try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(e){this.empty().append(a)}}else c.isFunction(a)?this.each(function(f){var h=c(this);h.html(a.call(this,f,h.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=
c(this),e=d.html();d.replaceWith(a.call(this,b,e))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){var e,f,h,l=a[0],k=[];if(!c.support.checkClone&&arguments.length===3&&typeof l==="string"&&Da.test(l))return this.each(function(){c(this).domManip(a,
b,d,true)});if(c.isFunction(l))return this.each(function(x){var r=c(this);a[0]=l.call(this,x,b?r.html():B);r.domManip(a,b,d)});if(this[0]){e=l&&l.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:c.buildFragment(a,this,k);h=e.fragment;if(f=h.childNodes.length===1?h=h.firstChild:h.firstChild){b=b&&c.nodeName(f,"tr");f=0;for(var o=this.length;f<o;f++)d.call(b?c.nodeName(this[f],"table")?this[f].getElementsByTagName("tbody")[0]||this[f].appendChild(this[f].ownerDocument.createElement("tbody")):
this[f]:this[f],f>0||e.cacheable||this.length>1?h.cloneNode(true):h)}k.length&&c.each(k,Oa)}return this}});c.buildFragment=function(a,b,d){var e,f,h;b=b&&b[0]?b[0].ownerDocument||b[0]:t;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===t&&!Ca.test(a[0])&&(c.support.checkClone||!Da.test(a[0]))){f=true;if(h=c.fragments[a[0]])if(h!==1)e=h}if(!e){e=b.createDocumentFragment();c.clean(a,b,e,d)}if(f)c.fragments[a[0]]=h?e:1;return{fragment:e,cacheable:f}};c.fragments={};c.each({appendTo:"append",
prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var e=[];d=c(d);var f=this.length===1&&this[0].parentNode;if(f&&f.nodeType===11&&f.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{f=0;for(var h=d.length;f<h;f++){var l=(f>0?this.clone(true):this).get();c(d[f])[b](l);e=e.concat(l)}return this.pushStack(e,a,d.selector)}}});c.extend({clean:function(a,b,d,e){b=b||t;if(typeof b.createElement==="undefined")b=b.ownerDocument||
b[0]&&b[0].ownerDocument||t;for(var f=[],h=0,l;(l=a[h])!=null;h++){if(typeof l==="number")l+="";if(l){if(typeof l==="string"&&!eb.test(l))l=b.createTextNode(l);else if(typeof l==="string"){l=l.replace(Aa,"<$1></$2>");var k=(Ba.exec(l)||["",""])[1].toLowerCase(),o=P[k]||P._default,x=o[0],r=b.createElement("div");for(r.innerHTML=o[1]+l+o[2];x--;)r=r.lastChild;if(!c.support.tbody){x=db.test(l);k=k==="table"&&!x?r.firstChild&&r.firstChild.childNodes:o[1]==="<table>"&&!x?r.childNodes:[];for(o=k.length-
1;o>=0;--o)c.nodeName(k[o],"tbody")&&!k[o].childNodes.length&&k[o].parentNode.removeChild(k[o])}!c.support.leadingWhitespace&&$.test(l)&&r.insertBefore(b.createTextNode($.exec(l)[0]),r.firstChild);l=r.childNodes}if(l.nodeType)f.push(l);else f=c.merge(f,l)}}if(d)for(h=0;f[h];h++)if(e&&c.nodeName(f[h],"script")&&(!f[h].type||f[h].type.toLowerCase()==="text/javascript"))e.push(f[h].parentNode?f[h].parentNode.removeChild(f[h]):f[h]);else{f[h].nodeType===1&&f.splice.apply(f,[h+1,0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
d.appendChild(f[h])}return f},cleanData:function(a){for(var b,d,e=c.cache,f=c.event.special,h=c.support.deleteExpando,l=0,k;(k=a[l])!=null;l++)if(!(k.nodeName&&c.noData[k.nodeName.toLowerCase()]))if(d=k[c.expando]){if((b=e[d])&&b.events)for(var o in b.events)f[o]?c.event.remove(k,o):c.removeEvent(k,o,b.handle);if(h)delete k[c.expando];else k.removeAttribute&&k.removeAttribute(c.expando);delete e[d]}}});var Ea=/alpha\([^)]*\)/i,gb=/opacity=([^)]*)/,hb=/-([a-z])/ig,ib=/([A-Z])/g,Fa=/^-?\d+(?:px)?$/i,
jb=/^-?\d/,kb={position:"absolute",visibility:"hidden",display:"block"},Pa=["Left","Right"],Qa=["Top","Bottom"],W,Ga,aa,lb=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){if(arguments.length===2&&b===B)return this;return c.access(this,a,b,true,function(d,e,f){return f!==B?c.style(d,e,f):c.css(d,e)})};c.extend({cssHooks:{opacity:{get:function(a,b){if(b){var d=W(a,"opacity","opacity");return d===""?"1":d}else return a.style.opacity}}},cssNumber:{zIndex:true,fontWeight:true,opacity:true,
zoom:true,lineHeight:true},cssProps:{"float":c.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,d,e){if(!(!a||a.nodeType===3||a.nodeType===8||!a.style)){var f,h=c.camelCase(b),l=a.style,k=c.cssHooks[h];b=c.cssProps[h]||h;if(d!==B){if(!(typeof d==="number"&&isNaN(d)||d==null)){if(typeof d==="number"&&!c.cssNumber[h])d+="px";if(!k||!("set"in k)||(d=k.set(a,d))!==B)try{l[b]=d}catch(o){}}}else{if(k&&"get"in k&&(f=k.get(a,false,e))!==B)return f;return l[b]}}},css:function(a,b,d){var e,f=c.camelCase(b),
h=c.cssHooks[f];b=c.cssProps[f]||f;if(h&&"get"in h&&(e=h.get(a,true,d))!==B)return e;else if(W)return W(a,b,f)},swap:function(a,b,d){var e={},f;for(f in b){e[f]=a.style[f];a.style[f]=b[f]}d.call(a);for(f in b)a.style[f]=e[f]},camelCase:function(a){return a.replace(hb,lb)}});c.curCSS=c.css;c.each(["height","width"],function(a,b){c.cssHooks[b]={get:function(d,e,f){var h;if(e){if(d.offsetWidth!==0)h=oa(d,b,f);else c.swap(d,kb,function(){h=oa(d,b,f)});if(h<=0){h=W(d,b,b);if(h==="0px"&&aa)h=aa(d,b,b);
if(h!=null)return h===""||h==="auto"?"0px":h}if(h<0||h==null){h=d.style[b];return h===""||h==="auto"?"0px":h}return typeof h==="string"?h:h+"px"}},set:function(d,e){if(Fa.test(e)){e=parseFloat(e);if(e>=0)return e+"px"}else return e}}});if(!c.support.opacity)c.cssHooks.opacity={get:function(a,b){return gb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var d=a.style;d.zoom=1;var e=c.isNaN(b)?"":"alpha(opacity="+b*100+")",f=
d.filter||"";d.filter=Ea.test(f)?f.replace(Ea,e):d.filter+" "+e}};if(t.defaultView&&t.defaultView.getComputedStyle)Ga=function(a,b,d){var e;d=d.replace(ib,"-$1").toLowerCase();if(!(b=a.ownerDocument.defaultView))return B;if(b=b.getComputedStyle(a,null)){e=b.getPropertyValue(d);if(e===""&&!c.contains(a.ownerDocument.documentElement,a))e=c.style(a,d)}return e};if(t.documentElement.currentStyle)aa=function(a,b){var d,e,f=a.currentStyle&&a.currentStyle[b],h=a.style;if(!Fa.test(f)&&jb.test(f)){d=h.left;
e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;h.left=b==="fontSize"?"1em":f||0;f=h.pixelLeft+"px";h.left=d;a.runtimeStyle.left=e}return f===""?"auto":f};W=Ga||aa;if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetHeight;return a.offsetWidth===0&&b===0||!c.support.reliableHiddenOffsets&&(a.style.display||c.css(a,"display"))==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var mb=c.now(),nb=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
ob=/^(?:select|textarea)/i,pb=/^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,qb=/^(?:GET|HEAD)$/,Ra=/\[\]$/,T=/\=\?(&|$)/,ja=/\?/,rb=/([?&])_=[^&]*/,sb=/^(\w+:)?\/\/([^\/?#]+)/,tb=/%20/g,ub=/#.*$/,Ha=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!=="string"&&Ha)return Ha.apply(this,arguments);else if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var f=a.slice(e,a.length);a=a.slice(0,e)}e="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===
"object"){b=c.param(b,c.ajaxSettings.traditional);e="POST"}var h=this;c.ajax({url:a,type:e,dataType:"html",data:b,complete:function(l,k){if(k==="success"||k==="notmodified")h.html(f?c("<div>").append(l.responseText.replace(nb,"")).find(f):l.responseText);d&&h.each(d,[l.responseText,k,l])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&
!this.disabled&&(this.checked||ob.test(this.nodeName)||pb.test(this.type))}).map(function(a,b){var d=c(this).val();return d==null?null:c.isArray(d)?c.map(d,function(e){return{name:b.name,value:e}}):{name:b.name,value:d}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:e})},
getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:e})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return new E.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",
script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},ajax:function(a){var b=c.extend(true,{},c.ajaxSettings,a),d,e,f,h=b.type.toUpperCase(),l=qb.test(h);b.url=b.url.replace(ub,"");b.context=a&&a.context!=null?a.context:b;if(b.data&&b.processData&&typeof b.data!=="string")b.data=c.param(b.data,b.traditional);if(b.dataType==="jsonp"){if(h==="GET")T.test(b.url)||(b.url+=(ja.test(b.url)?"&":"?")+(b.jsonp||"callback")+"=?");else if(!b.data||
!T.test(b.data))b.data=(b.data?b.data+"&":"")+(b.jsonp||"callback")+"=?";b.dataType="json"}if(b.dataType==="json"&&(b.data&&T.test(b.data)||T.test(b.url))){d=b.jsonpCallback||"jsonp"+mb++;if(b.data)b.data=(b.data+"").replace(T,"="+d+"$1");b.url=b.url.replace(T,"="+d+"$1");b.dataType="script";var k=E[d];E[d]=function(m){if(c.isFunction(k))k(m);else{E[d]=B;try{delete E[d]}catch(p){}}f=m;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);r&&r.removeChild(A)}}if(b.dataType==="script"&&b.cache===null)b.cache=
false;if(b.cache===false&&l){var o=c.now(),x=b.url.replace(rb,"$1_="+o);b.url=x+(x===b.url?(ja.test(b.url)?"&":"?")+"_="+o:"")}if(b.data&&l)b.url+=(ja.test(b.url)?"&":"?")+b.data;b.global&&c.active++===0&&c.event.trigger("ajaxStart");o=(o=sb.exec(b.url))&&(o[1]&&o[1].toLowerCase()!==location.protocol||o[2].toLowerCase()!==location.host);if(b.dataType==="script"&&h==="GET"&&o){var r=t.getElementsByTagName("head")[0]||t.documentElement,A=t.createElement("script");if(b.scriptCharset)A.charset=b.scriptCharset;
A.src=b.url;if(!d){var C=false;A.onload=A.onreadystatechange=function(){if(!C&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){C=true;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);A.onload=A.onreadystatechange=null;r&&A.parentNode&&r.removeChild(A)}}}r.insertBefore(A,r.firstChild);return B}var J=false,w=b.xhr();if(w){b.username?w.open(h,b.url,b.async,b.username,b.password):w.open(h,b.url,b.async);try{if(b.data!=null&&!l||a&&a.contentType)w.setRequestHeader("Content-Type",
b.contentType);if(b.ifModified){c.lastModified[b.url]&&w.setRequestHeader("If-Modified-Since",c.lastModified[b.url]);c.etag[b.url]&&w.setRequestHeader("If-None-Match",c.etag[b.url])}o||w.setRequestHeader("X-Requested-With","XMLHttpRequest");w.setRequestHeader("Accept",b.dataType&&b.accepts[b.dataType]?b.accepts[b.dataType]+", */*; q=0.01":b.accepts._default)}catch(I){}if(b.beforeSend&&b.beforeSend.call(b.context,w,b)===false){b.global&&c.active--===1&&c.event.trigger("ajaxStop");w.abort();return false}b.global&&
c.triggerGlobal(b,"ajaxSend",[w,b]);var L=w.onreadystatechange=function(m){if(!w||w.readyState===0||m==="abort"){J||c.handleComplete(b,w,e,f);J=true;if(w)w.onreadystatechange=c.noop}else if(!J&&w&&(w.readyState===4||m==="timeout")){J=true;w.onreadystatechange=c.noop;e=m==="timeout"?"timeout":!c.httpSuccess(w)?"error":b.ifModified&&c.httpNotModified(w,b.url)?"notmodified":"success";var p;if(e==="success")try{f=c.httpData(w,b.dataType,b)}catch(q){e="parsererror";p=q}if(e==="success"||e==="notmodified")d||
c.handleSuccess(b,w,e,f);else c.handleError(b,w,e,p);d||c.handleComplete(b,w,e,f);m==="timeout"&&w.abort();if(b.async)w=null}};try{var g=w.abort;w.abort=function(){w&&Function.prototype.call.call(g,w);L("abort")}}catch(i){}b.async&&b.timeout>0&&setTimeout(function(){w&&!J&&L("timeout")},b.timeout);try{w.send(l||b.data==null?null:b.data)}catch(n){c.handleError(b,w,null,n);c.handleComplete(b,w,e,f)}b.async||L();return w}},param:function(a,b){var d=[],e=function(h,l){l=c.isFunction(l)?l():l;d[d.length]=
encodeURIComponent(h)+"="+encodeURIComponent(l)};if(b===B)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){e(this.name,this.value)});else for(var f in a)da(f,a[f],b,e);return d.join("&").replace(tb,"+")}});c.extend({active:0,lastModified:{},etag:{},handleError:function(a,b,d,e){a.error&&a.error.call(a.context,b,d,e);a.global&&c.triggerGlobal(a,"ajaxError",[b,a,e])},handleSuccess:function(a,b,d,e){a.success&&a.success.call(a.context,e,d,b);a.global&&c.triggerGlobal(a,"ajaxSuccess",
[b,a])},handleComplete:function(a,b,d){a.complete&&a.complete.call(a.context,b,d);a.global&&c.triggerGlobal(a,"ajaxComplete",[b,a]);a.global&&c.active--===1&&c.event.trigger("ajaxStop")},triggerGlobal:function(a,b,d){(a.context&&a.context.url==null?c(a.context):c.event).trigger(b,d)},httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===1223}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),
e=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(e)c.etag[b]=e;return a.status===304},httpData:function(a,b,d){var e=a.getResponseHeader("content-type")||"",f=b==="xml"||!b&&e.indexOf("xml")>=0;a=f?a.responseXML:a.responseText;f&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b==="json"||!b&&e.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&e.indexOf("javascript")>=0)c.globalEval(a);return a}});
if(E.ActiveXObject)c.ajaxSettings.xhr=function(){if(E.location.protocol!=="file:")try{return new E.XMLHttpRequest}catch(a){}try{return new E.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}};c.support.ajax=!!c.ajaxSettings.xhr();var ea={},vb=/^(?:toggle|show|hide)$/,wb=/^([+\-]=)?([\d+.\-]+)(.*)$/,ba,pa=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b,d){if(a||a===0)return this.animate(S("show",
3),a,b,d);else{d=0;for(var e=this.length;d<e;d++){a=this[d];b=a.style.display;if(!c.data(a,"olddisplay")&&b==="none")b=a.style.display="";b===""&&c.css(a,"display")==="none"&&c.data(a,"olddisplay",qa(a.nodeName))}for(d=0;d<e;d++){a=this[d];b=a.style.display;if(b===""||b==="none")a.style.display=c.data(a,"olddisplay")||""}return this}},hide:function(a,b,d){if(a||a===0)return this.animate(S("hide",3),a,b,d);else{a=0;for(b=this.length;a<b;a++){d=c.css(this[a],"display");d!=="none"&&c.data(this[a],"olddisplay",
d)}for(a=0;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b,d){var e=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||e?this.each(function(){var f=e?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(S("toggle",3),a,b,d);return this},fadeTo:function(a,b,d,e){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d,e)},animate:function(a,b,d,e){var f=c.speed(b,
d,e);if(c.isEmptyObject(a))return this.each(f.complete);return this[f.queue===false?"each":"queue"](function(){var h=c.extend({},f),l,k=this.nodeType===1,o=k&&c(this).is(":hidden"),x=this;for(l in a){var r=c.camelCase(l);if(l!==r){a[r]=a[l];delete a[l];l=r}if(a[l]==="hide"&&o||a[l]==="show"&&!o)return h.complete.call(this);if(k&&(l==="height"||l==="width")){h.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY];if(c.css(this,"display")==="inline"&&c.css(this,"float")==="none")if(c.support.inlineBlockNeedsLayout)if(qa(this.nodeName)===
"inline")this.style.display="inline-block";else{this.style.display="inline";this.style.zoom=1}else this.style.display="inline-block"}if(c.isArray(a[l])){(h.specialEasing=h.specialEasing||{})[l]=a[l][1];a[l]=a[l][0]}}if(h.overflow!=null)this.style.overflow="hidden";h.curAnim=c.extend({},a);c.each(a,function(A,C){var J=new c.fx(x,h,A);if(vb.test(C))J[C==="toggle"?o?"show":"hide":C](a);else{var w=wb.exec(C),I=J.cur()||0;if(w){var L=parseFloat(w[2]),g=w[3]||"px";if(g!=="px"){c.style(x,A,(L||1)+g);I=(L||
1)/J.cur()*I;c.style(x,A,I+g)}if(w[1])L=(w[1]==="-="?-1:1)*L+I;J.custom(I,L,g)}else J.custom(I,C,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var e=d.length-1;e>=0;e--)if(d[e].elem===this){b&&d[e](true);d.splice(e,1)}});b||this.dequeue();return this}});c.each({slideDown:S("show",1),slideUp:S("hide",1),slideToggle:S("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){c.fn[a]=function(d,e,f){return this.animate(b,
d,e,f)}});c.extend({speed:function(a,b,d){var e=a&&typeof a==="object"?c.extend({},a):{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};e.duration=c.fx.off?0:typeof e.duration==="number"?e.duration:e.duration in c.fx.speeds?c.fx.speeds[e.duration]:c.fx.speeds._default;e.old=e.complete;e.complete=function(){e.queue!==false&&c(this).dequeue();c.isFunction(e.old)&&e.old.call(this)};return e},easing:{linear:function(a,b,d,e){return d+e*a},swing:function(a,b,d,e){return(-Math.cos(a*
Math.PI)/2+0.5)*e+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a=parseFloat(c.css(this.elem,this.prop));return a&&a>-1E4?a:0},custom:function(a,b,d){function e(l){return f.step(l)}
var f=this,h=c.fx;this.startTime=c.now();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;this.pos=this.state=0;e.elem=this.elem;if(e()&&c.timers.push(e)&&!ba)ba=setInterval(h.tick,h.interval)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;
this.custom(this.cur(),0)},step:function(a){var b=c.now(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var e in this.options.curAnim)if(this.options.curAnim[e]!==true)d=false;if(d){if(this.options.overflow!=null&&!c.support.shrinkWrapBlocks){var f=this.elem,h=this.options;c.each(["","X","Y"],function(k,o){f.style["overflow"+o]=h.overflow[k]})}this.options.hide&&c(this.elem).hide();if(this.options.hide||
this.options.show)for(var l in this.options.curAnim)c.style(this.elem,l,this.options.orig[l]);this.options.complete.call(this.elem)}return false}else{a=b-this.startTime;this.state=a/this.options.duration;b=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||b](this.state,a,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=
c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},interval:13,stop:function(){clearInterval(ba);ba=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===
b.elem}).length};var xb=/^t(?:able|d|h)$/i,Ia=/^(?:body|html)$/i;c.fn.offset="getBoundingClientRect"in t.documentElement?function(a){var b=this[0],d;if(a)return this.each(function(l){c.offset.setOffset(this,a,l)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);try{d=b.getBoundingClientRect()}catch(e){}var f=b.ownerDocument,h=f.documentElement;if(!d||!c.contains(h,b))return d||{top:0,left:0};b=f.body;f=fa(f);return{top:d.top+(f.pageYOffset||c.support.boxModel&&
h.scrollTop||b.scrollTop)-(h.clientTop||b.clientTop||0),left:d.left+(f.pageXOffset||c.support.boxModel&&h.scrollLeft||b.scrollLeft)-(h.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(x){c.offset.setOffset(this,a,x)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d,e=b.offsetParent,f=b.ownerDocument,h=f.documentElement,l=f.body;d=(f=f.defaultView)?f.getComputedStyle(b,null):b.currentStyle;
for(var k=b.offsetTop,o=b.offsetLeft;(b=b.parentNode)&&b!==l&&b!==h;){if(c.offset.supportsFixedPosition&&d.position==="fixed")break;d=f?f.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;o-=b.scrollLeft;if(b===e){k+=b.offsetTop;o+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&xb.test(b.nodeName))){k+=parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}e=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"){k+=
parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}d=d}if(d.position==="relative"||d.position==="static"){k+=l.offsetTop;o+=l.offsetLeft}if(c.offset.supportsFixedPosition&&d.position==="fixed"){k+=Math.max(h.scrollTop,l.scrollTop);o+=Math.max(h.scrollLeft,l.scrollLeft)}return{top:k,left:o}};c.offset={initialize:function(){var a=t.body,b=t.createElement("div"),d,e,f,h=parseFloat(c.css(a,"marginTop"))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",
height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";a.insertBefore(b,a.firstChild);d=b.firstChild;e=d.firstChild;f=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=e.offsetTop!==5;this.doesAddBorderForTableAndCells=
f.offsetTop===5;e.style.position="fixed";e.style.top="20px";this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15;e.style.position=e.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==h;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.css(a,
"marginTop"))||0;d+=parseFloat(c.css(a,"marginLeft"))||0}return{top:b,left:d}},setOffset:function(a,b,d){var e=c.css(a,"position");if(e==="static")a.style.position="relative";var f=c(a),h=f.offset(),l=c.css(a,"top"),k=c.css(a,"left"),o=e==="absolute"&&c.inArray("auto",[l,k])>-1;e={};var x={};if(o)x=f.position();l=o?x.top:parseInt(l,10)||0;k=o?x.left:parseInt(k,10)||0;if(c.isFunction(b))b=b.call(a,d,h);if(b.top!=null)e.top=b.top-h.top+l;if(b.left!=null)e.left=b.left-h.left+k;"using"in b?b.using.call(a,
e):f.css(e)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),e=Ia.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.css(a,"marginTop"))||0;d.left-=parseFloat(c.css(a,"marginLeft"))||0;e.top+=parseFloat(c.css(b[0],"borderTopWidth"))||0;e.left+=parseFloat(c.css(b[0],"borderLeftWidth"))||0;return{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||t.body;a&&!Ia.test(a.nodeName)&&
c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(e){var f=this[0],h;if(!f)return null;if(e!==B)return this.each(function(){if(h=fa(this))h.scrollTo(!a?e:c(h).scrollLeft(),a?e:c(h).scrollTop());else this[d]=e});else return(h=fa(f))?"pageXOffset"in h?h[a?"pageYOffset":"pageXOffset"]:c.support.boxModel&&h.document.documentElement[d]||h.document.body[d]:f[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();
c.fn["inner"+b]=function(){return this[0]?parseFloat(c.css(this[0],d,"padding")):null};c.fn["outer"+b]=function(e){return this[0]?parseFloat(c.css(this[0],d,e?"margin":"border")):null};c.fn[d]=function(e){var f=this[0];if(!f)return e==null?null:this;if(c.isFunction(e))return this.each(function(l){var k=c(this);k[d](e.call(this,l,k[d]()))});if(c.isWindow(f))return f.document.compatMode==="CSS1Compat"&&f.document.documentElement["client"+b]||f.document.body["client"+b];else if(f.nodeType===9)return Math.max(f.documentElement["client"+
b],f.body["scroll"+b],f.documentElement["scroll"+b],f.body["offset"+b],f.documentElement["offset"+b]);else if(e===B){f=c.css(f,d);var h=parseFloat(f);return c.isNaN(h)?f:h}else return this.css(d,typeof e==="string"?e:e+"px")}})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>foundation/cljs.core.logic -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">foundation/cljs.core.logic</h1><h2 class="project-version">0.1.0-SNAPSHOT</h2><br />
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.6.0-alpha3</td></tr><tr><td class="dep-name">org.clojure/clojurescript</td><td class="dotted"><hr /></td><td class="dep-version">0.0-2080</td></tr><tr><td class="dep-name">org.clojure/core.async</td><td class="dotted"><hr /></td><td class="dep-version">0.1.256.0-1bf8cf-alpha</td></tr><tr><td class="dep-name">org.clojure/tools.namespace</td><td class="dotted"><hr /></td><td class="dep-version">0.2.4</td></tr><tr><td class="dep-name">org.clojure/data.generators</td><td class="dotted"><hr /></td><td class="dep-version">0.1.2</td></tr><tr><td class="dep-name">org.clojure/math.combinatorics</td><td class="dotted"><hr /></td><td class="dep-version">0.0.7</td></tr><tr><td class="dep-name">org.clojure/tools.reader</td><td class="dotted"><hr /></td><td class="dep-version">0.8.0</td></tr><tr><td class="dep-name">com.cemerick/double-check</td><td class="dotted"><hr /></td><td class="dep-version">0.5.4-SNAPSHOT</td></tr><tr><td class="dep-name">riddley</td><td class="dotted"><hr /></td><td class="dep-version">0.1.6</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#cljs.core.logic.bench">cljs.core.logic.bench</a></li><li><a href="#cljs.core.logic.macros">cljs.core.logic.macros</a></li><li><a href="#cljs.core.logic.nominal.macros">cljs.core.logic.nominal.macros</a></li><li><a href="#cljs.core.logic">cljs.core.logic</a></li><li><a href="#cljs.core.logic.bench">cljs.core.logic.bench</a></li><li><a href="#cljs.core.logic.dcg">cljs.core.logic.dcg</a></li><li><a href="#cljs.core.logic.fd">cljs.core.logic.fd</a></li><li><a href="#cljs.core.logic.nominal">cljs.core.logic.nominal</a></li><li><a href="#cljs.core.logic.pldb">cljs.core.logic.pldb</a></li><li><a href="#cljs.core.logic.pprint">cljs.core.logic.pprint</a></li><li><a href="#cljs.core.logic.protocols">cljs.core.logic.protocols</a></li><li><a href="#cljs.core.logic.unifier">cljs.core.logic.unifier</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.bench" name="cljs.core.logic.bench"><h1 class="project-name">cljs.core.logic.bench</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.bench
  (:refer-clojure :exclude [identity symbol ==])
  (:require [cljs.compiler :as comp]
            [cljs.core :as core]
            [cljs.env :as env]
            [cljs.analyzer :as ana]
            [clojure.set :as set]
            [clojure.string :as string]
            [clojure.math.combinatorics :as math]
            [clojure.core.async :as a
             :refer [go go-loop &lt;! take! put! &gt;! chan]]
            [riddley.compiler :refer [locals]]
            [clojure.core.reducers :as r]
            [clojure.data.generators :as gen]
            [clojure.pprint :refer [pprint]]
            [clojure.repl :refer [doc]]
            [riddley.walk :refer [macroexpand-all walk-exprs]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn emit-js
  [form]
  (let [env (ana/empty-env)
        ast (ana/analyze env form)
        js (comp/emit-str ast)]
    js))</pre></td></tr><tr><td class="docs"><p>(defmacro simple-let
  [bindings &amp; body]
  `((fn ~(->> (partition-all 2 bindings) (map first) (vec))
     ~@body)
    ~@(->> (partition-all 2 bindings) (map second))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def keyword-identical? identical?)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn unevaluated?
  [expr]
  (or (symbol? expr)
      (and (seq? expr)
           (not= (first expr) `quote))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn literal?
  [x]
  (and (not (unevaluated? x))
       (or (not (or (vector? x) (map? x)))
           (every? literal? x))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro some-identical?
  [v coll]
  (when (and (seq coll) (every? literal? coll))
    (let [coll (->> (interleave (repeat (count coll) v) coll)
                    (partition-all 2))]
      (cond (and (literal? v) (keyword? v))
            `(or ~@(map (fn [[val# item#]]
                          `(keyword-identical? ~val# ~item#)) coll))
            (literal? v)
            <code>(or ~@(map (fn [[val# item#]]</code>(identical? ~val# ~item#)) coll))
            :else
            `(or ~@(map (fn [[val# item#]]
                          (if (keyword? val#)
                            `(keyword-identical? ~val# ~item#)
                            `(identical? ~val# ~item#))) coll))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (let [rand-coll (doall (gen/collection))
        rand-val (gen/rand-nth (vec rand-coll))]
    (time (dotimes [i 100000]
            (some-identical? rand-val rand-coll)))
    (time (dotimes [i 100000]
            (some-identical? i rand-coll))))
  )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro our-let
  [bindings &amp; body]
  `((fn ~(->> (partition-all 2 bindings) (map first) vec)
      ~@body)
    ~@(->> (partition-all 2 bindings) (map second))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro when-bind
  [name expr &amp; body]
  `(let [~name ~expr]
     (when ~name
       ~@body)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro when-bind*
  [bindings &amp; body]
  (if-not (seq bindings)
    `(do ~@body)
    `(let ~(vec (first (partition 2 bindings)))
       (when ~(ffirst (partition 2 bindings))
         (when-bind* ~(rest (partition 2 bindings)) ~@body)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro with-gensyms
  [syms &amp; body]
  <code>(let ~(vec (map (fn [s#]</code>(~s# (gensym))) syms))
     ~@body))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn condlet-binds
  [syms bindings]
  (reduce (fn [bindings [k v :as binding-form]]
            (vec (concat bindings [(get syms k) v])))
          [] bindings))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn condlet-clause
  [syms clause bodyfn]
  `(~(first clause)
    (let [~@(interleave (vals syms) (repeat (count syms) nil))]
      (let [~@(condlet-binds syms (->> (rest clause)
                                       (apply concat)
                                       (partition 2)))]
        (~bodyfn ~@(vals syms))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn unique-bindings
  [bindings]
  (->> (apply concat bindings)
       (partition 2)
       (map first)
       (set)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro condlet
  [clauses &amp; body]
  (let [bodyfn (gensym)
        clauses (partition-all 2 clauses)
        syms (reduce (fn [m v] (assoc m v (gensym)))
                     {} (unique-bindings (mapcat rest clauses)))]
    `(letfn [(~bodyfn [~@(keys syms)] ~@body)]
       (cond ~@(apply concat
                      (map (fn [clause#]
                             (condlet-clause syms clause# bodyfn))
                           clauses))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro if3
  [test t-case nil-case ?-case]
  `(condp ~test =
     nil nil-case
     true t-case
     false nil-case
     ?-case))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro nif
  [expr pos zero neg]
  (let [g (gensym)]
    `(let [~g ~expr]
       (cond (pos? ~g) ~pos
             (zero? ~g) ~zero
             :else ~neg))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro prog1
  [form &amp; forms]
  `(let [val# ~form]
     ~@forms
     val#))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmacro prog2
  [fform sform &amp; forms]
  `(do ~fform (prog1 ~sform ~@forms)))</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.macros" name="cljs.core.logic.macros"><h1 class="project-name">cljs.core.logic.macros</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.macros
  (:refer-clojure :exclude [== = &lt; &gt; &lt;= &gt;=])
  (:require [cljs.compiler :as comp]
            [cljs.core :as core]
            [cljs.env :as env]
            [cljs.analyzer :as ana]
            [clojure.set :as set]
            [clojure.string :as string]
            [riddley.walk :refer [macroexpand-all walk-exprs]]
            [riddley.compiler :refer [locals]]
            [clojure.repl :refer [doc]])  
  (:import [java.io Writer]
           [java.util UUID]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *locals* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *logic-compiler-env* (env/default-compiler-env))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *logic-env*
  (env/with-compiler-env *logic-compiler-env*
    (assoc (ana/empty-env) :ns 'cljs.core.logic)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro umi
  [&amp; args]
  `(unchecked-multiply-int ~@args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro uai
  [&amp; args]
  `(unchecked-add-int ~@args))</pre></td></tr><tr><td class="docs"><p>Constructs a sequence from 2 or more arguments, with the last argument as 
   the tail. The tail is improper if the last argument is a logic variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro llist
  ([f s] `(cljs.core.logic/lcons ~f ~s))
  ([f s &amp; rest] `(cljs.core.logic/lcons ~f (llist ~s ~@rest))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro composeg*
  ([g0] g0)
  ([g0 &amp; gs]
     `(cljs.core.logic/composeg
       ~g0
       (composeg* ~@gs))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro bind*
  ([a g] `(cljs.core.logic.protocols/bind
           ~(vary-meta a {:tag 'not-native}) ~g))
  ([a g &amp; g-rest]
     `(bind* (cljs.core.logic.protocols/bind
              ~(vary-meta a {:tag 'not-native}) ~g) ~@g-rest)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro mplus*
  ([e] e)
  ([e &amp; e-rest]
     `(cljs.core.logic.protocols/mplus ~e (fn [] (mplus* ~@e-rest)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro -inc [&amp; rest]
  `(fn ~(quote -inc) [] ~@rest))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- bind-conde-clause [a]
  (fn [g-rest]
    `(bind* ~a ~@g-rest)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- bind-conde-clauses [a clauses]
  (map (bind-conde-clause a) clauses))</pre></td></tr><tr><td class="docs"><p>Logical disjunction of the clauses. The first goal in
  a clause is considered the head of that clause. Interleaves the
  execution of the clauses.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro conde
  [&amp; clauses]
  (let [a (gensym &quot;a&quot;)]
    `(fn [~a]
       (-inc
        (mplus* ~@(bind-conde-clauses a clauses))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- lvar-bind [sym]
  ((juxt identity
         (fn [s] `(cljs.core.logic/lvar '~s))) sym))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- lvar-binds [syms]
  (mapcat lvar-bind syms))</pre></td></tr><tr><td class="docs"><p>Creates fresh variables. Goals occuring within form a logical
  conjunction.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro fresh
  [[&amp; lvars] &amp; goals]
  `(fn [a#]
     (-inc
      (let [~@(lvar-binds lvars)]
        (bind* a# ~@goals)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro -run [opts [x :as bindings] &amp; goals]
  (if (clojure.core/&gt; (count bindings) 1)
    (let [[rbindings as-key [as]] (partition-by #{:as} bindings)]
      (if (seq as-key)
        `(-run ~opts [~as]
               (fresh [~@rbindings] (cljs.core.logic/== ~as [~@rbindings]) ~@goals))
        `(-run ~opts [q#] (fresh ~bindings (cljs.core.logic/== q# ~bindings) ~@goals))))
    `(let [opts# ~opts
           xs# (cljs.core.logic.protocols/take*
                (fn []
                  ((fresh [~x]
                     ~@goals
                     (cljs.core.logic/reifyg ~x))
                   (cljs.core.logic/tabled-s
                    (:occurs-check opts#)
                    (merge {:reify-vars true} opts#)))))]
       (if-let [n# (:n opts#)]
         (take n# xs#)
         xs#))))</pre></td></tr><tr><td class="docs"><p>Executes goals until a maximum of n results are found.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro run
  [n bindings &amp; goals]
  `(-run {:occurs-check true :n ~n :db cljs.core.logic/*logic-dbs*}
         ~bindings ~@goals))</pre></td></tr><tr><td class="docs"><p>Executes goals until results are exhausted.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro run*
  [bindings &amp; goals]
  `(-run {:occurs-check true :n false :db cljs.core.logic/*logic-dbs*}
         ~bindings ~@goals))</pre></td></tr><tr><td class="docs"><p>Executes goals until a maximum of n results are found. Uses a specified logic database.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro run-db
  [n db bindings &amp; goals]
  `(-run {:occurs-check true :n ~n :db (flatten [~db])} ~bindings ~@goals))</pre></td></tr><tr><td class="docs"><p>Executes goals until results are exhausted. Uses a specified logic database.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro run-db*
  [db bindings &amp; goals]
  `(-run {:occurs-check true :n false :db (flatten [~db])} ~bindings ~@goals))</pre></td></tr><tr><td class="docs"><p>Executes goals until a maximum of n results are found. Does not
   occurs-check.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro run-nc
  [n bindings &amp; goals]
  `(-run {:occurs-check false :n ~n :db cljs.core.logic/*logic-dbs*}
         ~bindings ~@goals))</pre></td></tr><tr><td class="docs"><p>Executes goals until results are exhausted. Does not occurs-check.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro run-nc*
  [&amp; goals]
  `(run-nc false ~@goals))</pre></td></tr><tr><td class="docs"><p>Like fresh but does does not create logic variables.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro all
  ([] `cljs.core.logic/s#)
  ([&amp; goals] `(fn [a#] (bind* a# ~@goals))))</pre></td></tr><tr><td class="docs"><p>=============================================================================
Debugging</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro log [&amp; s]
  &quot;Goal for println&quot;
  `(fn [a#]
     (println ~@s)
     a#))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro trace-s []
  &quot;Goal that prints the current substitution&quot;
  `(fn [a#]
     (println (str a#))
     a#))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trace-lvar [a lvar]
  `(println (format &quot;%5s = %s&quot; (str '~lvar) (-reify ~a ~lvar))))</pre></td></tr><tr><td class="docs"><p>Goal for tracing the values of logic variables.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro trace-lvars
  [title &amp; lvars]
  (let [a (gensym &quot;a&quot;)]
    `(fn [~a]
       (println ~title)
       ~@(map (partial trace-lvar a) lvars)
       ~a)))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Non-relational goals</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>===========================================================================
project</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- project-binding [s]
  (fn [var]
    `(~var (cljs.core.logic/walk* ~s ~var))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- project-bindings [vars s]
  (reduce concat (map (project-binding s) vars)))</pre></td></tr><tr><td class="docs"><p>Extract the values bound to the specified logic vars. Non-relational.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro project
  [[&amp; vars] &amp; goals]
  (let [a (gensym &quot;a&quot;)]
    `(fn [~a]
       (let [~@(project-bindings vars a)]
         ((fresh []
            ~@goals) ~a)))))</pre></td></tr><tr><td class="docs"><p>Check a predicate against the value logic var. Non-relational.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro pred
  [v f]
  `(project [~v]
            (cljs.core.logic/== (~f ~v) true)))</pre></td></tr><tr><td class="docs"><p>TODO: remove v argument - David</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Set the value of a var to value of another var with the operation
   applied. Non-relational.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro is
  [u v op]
  `(project [~v]
            (cljs.core.logic/== ~u (~op ~v))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ifa*
  ([])
  ([[e &amp; gs] &amp; grest]
     `(cljs.core.logic.protocols/ifa ~e [~@gs]
           ~(if (seq grest)
              `(delay (ifa* ~@grest))
              nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ifu*
  ([])
  ([[e &amp; gs] &amp; grest]
     `(cljs.core.logic.protocols/ifu
       ~e [~@gs]
       ~(if (seq grest)
          `(delay (ifu* ~@grest))
          nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- cond-clauses [a]
  (fn [goals]
    `((~(first goals) ~a) ~@(rest goals))))</pre></td></tr><tr><td class="docs"><p>Soft cut. Once the head of a clause has succeeded
  all other clauses will be ignored. Non-relational.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro conda
  [&amp; clauses]
  (let [a (gensym &quot;a&quot;)]
    `(fn [~a]
       (ifa* ~@(map (cond-clauses a) clauses)))))</pre></td></tr><tr><td class="docs"><p>Committed choice. Once the head (first goal) of a clause
  has succeeded, remaining goals of the clause will only
  be run once. Non-relational.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro condu
  [&amp; clauses]
  (let [a (gensym &quot;a&quot;)]
    `(fn [~a]
       (ifu* ~@(map (cond-clauses a) clauses)))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
lvar nonlvar</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A goal that succeeds if the argument is fresh. v must be a logic
  variable. Non-relational.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro lvaro
  [v]
  `(fn [a#]
     (if (lvar? (cljs.core.logic.protocols/walk a# ~v))
       a# nil)))</pre></td></tr><tr><td class="docs"><p>A goal that succeeds if the argument is not fresh. v must be a
  logic variable. Non-relational.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro nonlvaro
  [v]
  `(fn [a#]
     (if (not (lvar? (cljs.core.logic.protocols/walk a# ~v)))
       a# nil)))</pre></td></tr><tr><td class="docs"><p>==========================================================================
Pattern matching</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- warn [&amp; msg]
  (binding [*out* *err*]
    (apply println &quot;WARNING:&quot; msg)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare p-&gt;term)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- lcons-p? [p]
  (and (coll? p)
       (not (nil? (some '#{.} p)))))</pre></td></tr><tr><td class="docs"><p>Take an lcons pattern and convert it into a llist constructor
   expression.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- p-&gt;llist
  ([p vars] (p-&gt;llist p vars false))
  ([p vars quoted]
     `(llist
       ~@(doall
          (map #(p-&gt;term % vars quoted)
               (remove #(contains? '#{.} %) p))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- lvar-sym? [s]
  (and (symbol? s)
       (not= s '.)
       (not (contains? *locals* s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn update-pvars! [x vars]
  (if (lvar-sym? x)
    (do
      (swap! vars conj x)
      x)
    x))</pre></td></tr><tr><td class="docs"><p>Convert a pattern p into a term suitable for unification. Takes an atom
   containing a set for returning any encountered vars which will be declared
   fresh.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- p-&gt;term
  ([p vars] (p-&gt;term p vars false))
  ([p vars quoted]
     (cond
      (clojure.core/= p '_) `(cljs.core.logic/lvar)
      (lcons-p? p) (p-&gt;llist p vars quoted)
      (coll? p)
      (cond
       ;; support simple expressions
       (seq? p)
       (let [[f s] p]
         (cond
          (clojure.core/= f 'quote)
          (if (and (seq? s) (not quoted))
            (p-&gt;term s vars true)
            p)
          (clojure.core/= f 'clojure.core/unquote)
          (if quoted
            (update-pvars! s vars)
            (throw (Exception. &quot;Invalid use of clojure.core/unquote in pattern.&quot;)))
          :else
          (let [ps (map #(p-&gt;term % vars quoted) p)]
            (if quoted
              `(list ~@ps)
              ps))))
       ;; preserve original collection type
       :else
       (let [ps (map #(p-&gt;term % vars quoted) p)]
         (cond
          (instance? clojure.lang.IMapEntry p) (into [] ps)
          :else (into (empty p) ps))))
      (symbol? p) (if quoted
                    (list 'quote p)
                    (update-pvars! p vars))
      :else p)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- fresh-expr? [cs]
  (clojure.core/= (first cs) `fresh))</pre></td></tr><tr><td class="docs"><p>Takes a list of vars to declare fresh and a term t to be unified
   with relation argument a.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- ex
  ([vs t a]
     `(fresh [~@vs]
        (cljs.core.logic/== ~t ~a)))
  ([vs t a exprs]
     (if (fresh-expr? exprs)
       `(fresh [~@vs]
          (cljs.core.logic/== ~t ~a)
          ~exprs)
       `(fresh [~@vs]
          (cljs.core.logic/== ~t ~a)
          ~@exprs))))</pre></td></tr><tr><td class="docs"><p>Takes a sequence of pattern/argument pairs, goal expressions and
   a set of seen variables. Returns source code that represents the
   equivalent miniKanren series of unifications.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- ex*
  [[[p a :as pa] &amp; par] exprs seen]
  (let [vars (atom #{})
        t    (p-&gt;term p vars)
        vs   (set/difference @vars seen)
        seen (reduce conj seen vs)]
    (cond
     (nil? pa) exprs
     (clojure.core/= p '_) (ex* par exprs seen)
     (empty? par) (if exprs
                    (ex vs t a exprs)
                    (ex vs t a))
     :else (let [r (ex* par exprs seen)]
             (if r
               (ex vs t a r)
               (ex vs t a))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- all-blank? [p]
  (every? #(identical? % '_) p))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- handle-clause [as]
  (when-not (vector? as)
    (throw (Exception. (str &quot;Expecting vector of arguments, instead &quot; as))))
  (fn [[p &amp; exprs]]
    (when-not (vector? p)
      (throw (Exception. (str &quot;Expecting vector of matches, instead &quot; p))))
    (when-not (clojure.core/= (count p) (count as))
      (warn &quot;Differing number of matches. Matching&quot; p &quot;against&quot; as))
    (let [pas (partition 2 (interleave p as))
          r (ex* pas exprs #{})]
      (if (all-blank? p)
        r
        (list r)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- handle-clauses [t as cs]
  `(~t
    ~@(doall (map (handle-clause as) cs))))</pre></td></tr><tr><td class="docs"><p>To be used in macro definitions.
   Handles optional docstrings and attribute maps for a name to be defined
   in a list of macro arguments. If the first macro argument is a string
   it is added as a docstring to name and removed from the macro argument
   list. If afterwards the first macro argument is a map, its entries are
   added to the name's metadata map and the map is removed from the
   macro argument list. The return value is a vector containing the name
   with its extended metadata map and the list of unprocessed macro
   arguments.</p>

<p>name-with-attributes by Konrad Hinsen, from clojure.contrib.def</p>
</td><td class="codes"><pre class="brush: clojure">(defn- name-with-attributes
  [name macro-args]
  (let [[docstring macro-args] (if (string? (first macro-args))
                                 [(first macro-args) (next macro-args)]
                                 [nil macro-args])
        [attr macro-args]          (if (map? (first macro-args))
                                     [(first macro-args) (next macro-args)]
                                     [{} macro-args])
        attr                       (if docstring
                                     (assoc attr :doc docstring)
                                     attr)
        attr                       (if (meta name)
                                     (conj (meta name) attr)
                                     attr)]
    [(with-meta name attr) macro-args]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare tabled)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn env-locals [&amp; syms]
  (disj (set (apply concat syms)) '_))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro -fnm [fn-gen t as &amp; cs]
  (binding [*locals* (env-locals as (keys &amp;env))]
    `(~fn-gen [~@as] ~(handle-clauses t as cs))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def keyword-identical? identical?)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro fnm
  {:arglists '([t as tabled? &amp; cs])}
  [t as &amp; cs]
  (if-let [cs (and (keyword-identical? (first cs) :tabled) (rest cs))]
    `(-fnm tabled ~t ~as ~@cs)
    `(-fnm fn ~t ~as ~@cs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro defnm [t n &amp; rest]
  (let [[n [as &amp; cs]] (name-with-attributes n rest)
        e (if (-&gt; n meta :tabled)
            `(fnm ~t ~as :tabled ~@cs)
            `(fnm ~t ~as ~@cs))]
    `(def ~n ~e)))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Goal sugar syntax</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Define an anonymous goal fn. Supports pattern matching. All
   patterns will be tried. See conde.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro fne
  [&amp; rest]
  `(fnm conde ~@rest))</pre></td></tr><tr><td class="docs"><p>Define a goal fn. Supports pattern matching. All
   patterns will be tried. See conde.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defne
  [&amp; rest]
  `(defnm conde ~@rest))</pre></td></tr><tr><td class="docs"><p>Pattern matching macro. All patterns will be tried.
  See conde.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro matche
  [xs &amp; cs]
  (binding [*locals* (env-locals xs (-&gt; &amp;env :locals keys))]
    (handle-clauses `conde xs cs)))</pre></td></tr><tr><td class="docs"><p><hr />
fnu, fna, defnu, defna, matcha, matchu</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TODO: we need to rethink (de)fna and (de)fnu, the unification comes first
the <em>question</em> should come first</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Define an anonymous soft cut goal. See conda.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro fna
  [&amp; rest]
  `(fnm conda ~@rest))</pre></td></tr><tr><td class="docs"><p>Define an anonymous committed choice goal. See condu.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro fnu
  [&amp; rest]
  `(fnm condu ~@rest))</pre></td></tr><tr><td class="docs"><p>Define a soft cut goal. See conda.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defna
  [&amp; rest]
  `(defnm conda ~@rest))</pre></td></tr><tr><td class="docs"><p>Define a committed choice goal. See condu.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defnu
  [&amp; rest]
  `(defnm condu ~@rest))</pre></td></tr><tr><td class="docs"><p>Define a soft cut pattern match. See conda.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro matcha
  [xs &amp; cs]
  (binding [*locals* (env-locals xs (-&gt; &amp;env :locals keys))]
    (handle-clauses `conda xs cs)))</pre></td></tr><tr><td class="docs"><p>Define a committed choice goal. See condu.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro matchu
  [xs &amp; cs]
  (binding [*locals* (env-locals xs (-&gt; &amp;env :locals keys))]
    (handle-clauses `condu xs cs)))</pre></td></tr><tr><td class="docs"><p><hr />
Syntax</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TODO: consider the concurrency implications much more closely</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Macro for defining a tabled goal. Prefer ^:tabled with the
  defne/a/u forms over using this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro tabled
    [args &amp; grest]
    (let [uuid (symbol (str &quot;tabled-&quot; (UUID/randomUUID)))]
      `(fn ~uuid [~@args]
         (let [argv# ~args]
           (fn [a#]
             (let [key#    (cljs.core.logic/-reify a# argv#)
                   tables# (:ts a#)
                   tables# (if-not (contains? @tables# ~uuid)
                             (swap! tables#
                                    (fn [tables#]
                                      (if (contains? tables# ~uuid)
                                        tables#
                                        (assoc tables# ~uuid (atom {})))))
                             @tables#)
                   table#  (get tables# ~uuid)]
               (if-not (contains? @table# key#)
                 (let [table#
                       (swap! table#
                              (fn [table#]
                                (if (contains? table# key#)
                                  table#
                                  (assoc table# key#
                                         (atom
                                          (cljs.core.logic/answer-cache))))))
                       cache# (get table# key#)]
                   ((fresh []
                      ~@grest
                      (cljs.core.logic/master argv# cache#)) a#))
                 (let [cache# (get @table# key#)]
                   (cljs.core.logic.protocols/reuse
                    a# argv# cache# nil nil)))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro let-dom
  [a vars &amp; body]
  (let [get-var-dom (fn [a [v b]]
                      `(~b (cljs.core.logic/get-dom-fd ~a ~v)))]
    `(let [~@(mapcat (partial get-var-dom a) (partition 2 vars))]
       ~@body)))</pre></td></tr><tr><td class="docs"><p>consider ^:partial type hint for arguments
these argument only need to be partially instantiated</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Define an anonymous constraint that can be used with the unifier:</p>

<pre><code> (let [oddc (fnc [x] (odd? x))]

   (unifier {:a '?a} {:a 1} :when {'?a oddc})
     ;;=&gt; {:a 1}

   (unifier {:a '?a} {:a 2} :when {'?a oddc})
     ;;=&gt; nil
 )
</code></pre>

<p>  Note, the constraint will not run until all arguments are fully ground.</p>

<p>  Use defnc to define a constraint and assign a toplevel var.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro fnc
  [args &amp; body]
  (let [name (symbol (gensym &quot;fnc&quot;))]
    `(fn ~args
       (letfn [(~name [~@args]
                 (reify
                   cljs.core.logic.protocols/IConstraintStep
                   (~'-step [this# a#]
                     (reify
                       cljs.core/IFn
                       (~'-invoke [_# a#]
                         (let [[~@args :as args#]
                               (map #(cljs.core.logic/walk* a# %) ~args)
                               test# (do ~@body)]
                           (when test#
                             ((cljs.core.logic/remcg this#) a#))))
                       cljs.core.logic.protocols/IRunnable
                       (~'-runnable? [_#]
                         (cljs.core.logic/ground-term? ~args a#))))
                   cljs.core.logic.protocols/IConstraintOp
                   (~'-rator [_#] '~name)
                   (~'-rands [_#]
                     (filter cljs.core.logic/lvar? (flatten ~args)))
                   cljs.core.logic.protocols/IReifiableConstraint
                   (~'-reifyc [_# _# r# a#]
                     (list '~name (map #(cljs.core.logic/-reify r# %) ~args)))
                   cljs.core.logic.protocols/IConstraintWatchedStores
                   (~'-watched-stores [_#] #{:cljs.core.logic/subst})))]
         (cljs.core.logic/cgoal (~name ~@args))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro defnc [name args &amp; body]
  `(def ~name (fnc ~args ~@body)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro extend-to-fd [t]
  `(extend-type ~t
     cljs.core.logic.protocols/IMemberCount
     (~'-member-count [this#] 1)
     cljs.core.logic.fd/IInterval
     (~'-lb [this#] this#)
     (~'-ub [this#] this#)
     cljs.core.logic.fd/ISortedDomain
     (~'-drop-one [this#]
       nil)
     (~'-drop-before [this# n#]
       (when (clojure.core/&gt;= this# n#)
         this#))
     (~'-keep-before [this# n#]
       (when (clojure.core/&lt; this# n#)
         this#))
     cljs.core.logic.fd/ISet
     (~'-member? [this# that#]
       (if (integer? that#)
         (clojure.core/== this# that#)
         (cljs.core.logic.fd/-member? that# this#)))
     (~'-disjoint? [this# that#]
       (if (integer? that#)
         (not (clojure.core/== this# that#))
         (cljs.core.logic.fd/-disjoint? that# this#)))
     (~'-intersection [this# that#]
       (cond
        (integer? that#) (when (clojure.core/== this# that#)
                           this#)
        (cljs.core.logic.fd/interval? that#)
        (cljs.core.logic.fd/-intersection that# this#)
        :else (cljs.core.logic.fd/intersection* this# that#)))
     (~'-difference [this# that#]
       (cond
        (integer? that#) (if (clojure.core/== this# that#)
                           nil
                           this#)
        (cljs.core.logic.fd/interval? that#)
        (cljs.core.logic.fd/-difference that# this#)
        :else (cljs.core.logic.fd/difference* this# that#)))
     cljs.core.logic.fd/IIntervals
     (~'-intervals [this#]
       (list this#))))</pre></td></tr><tr><td class="docs"><p>Assign vars to domain. The domain must come last.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro in
  [&amp; xs-and-dom]
  (let [xs (butlast xs-and-dom)
        dom (last xs-and-dom)
        domsym (gensym &quot;dom_&quot;)]
    `(let [~domsym ~dom]
       (fresh []
         ~@(map (fn [x#]
                  `(cljs.core.logic.fd/dom ~x# ~domsym))
                xs)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def binops-&gt;fd
  '{+  cljs.core.logic.fd/+
    -  cljs.core.logic.fd/-
    *  cljs.core.logic.fd/*
    /  cljs.core.logic.fd/quot
    =  cljs.core.logic.fd/==
    != cljs.core.logic.fd/!=
    &lt;= cljs.core.logic.fd/&lt;=
    &lt;  cljs.core.logic.fd/&lt;
    &gt;= cljs.core.logic.fd/&gt;=
    &gt;  cljs.core.logic.fd/&gt;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def binops (set (keys binops-&gt;fd)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn expand [form]
  (if (seq? form)
    (let [[op &amp; args] form]
      (if (and (binops op) (clojure.core/&gt; (count args) 2))
        (list op (expand (first args))
              (expand (cons op (rest args))))
        (cons op (map expand args))))
    form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn eq*
  ([form vars] (eq* form vars nil))
  ([form vars out]
     (if (seq? form)
       (let [[op r1 r2] form
             [outl outlv?] (if (seq? r1)
                             (let [s (gensym)]
                               (swap! vars conj s)
                               [s true])
                             [r1 false])
             [outr outrv?] (if (seq? r2)
                             (let [s (gensym)]
                               (swap! vars conj s)
                               [s true])
                             [r2 false])
             op (binops-&gt;fd op)]
         (cons (if out
                 (list op outl outr out)
                 (list op outl outr))
               (concat (when (seq? r1)
                         (eq* r1 vars (when outlv? outl)))
                       (when (seq? r2)
                         (eq* r2 vars (when outrv? outr))))))
       form)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -&gt;fd [vars exprs]
  `(fresh [~@vars]
     ~@(reverse exprs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn eq-form [form]
  (let [vars (atom [])
        exprs (eq* (expand form) vars)]
    (-&gt;fd @vars exprs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro eq [&amp; forms]
  `(all
    ~@(map eq-form forms)))</pre></td></tr><tr><td class="docs"><hr />
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def empty-db {})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-dbs [dbs &amp; body]
  `(binding [cljs.core.logic/*logic-dbs*
             (concat cljs.core.logic/*logic-dbs* ~dbs)]
     ~@body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-db [db &amp; body]
  `(binding [cljs.core.logic/*logic-dbs*
             (conj cljs.core.logic/*logic-dbs* ~db)]
     ~@body))</pre></td></tr><tr><td class="docs"><hr />
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn indexed? [v]
  (true? (:index (meta v))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro db-rel [name &amp; args]
  (let [arity
        (count args)
        kname
        (str name &quot;_&quot; arity)
        indexes
        (vec (map indexed? args))]
    `(def ~name
       (with-meta
         (fn [&amp; query#]
           (fn [subs#]
             (let [dbs#
                   (-&gt; subs# clojure.core/meta :db)
                   facts#
                   (if-let [index# (cljs.core.logic.pldb/index-for-query
                                    subs# query# ~indexes)]
                     (cljs.core.logic.pldb/facts-using-index
                      dbs#
                      ~kname
                      index#
                      (cljs.core.logic/walk* subs# (nth query# index#)))
                     (cljs.core.logic.pldb/facts-for dbs# ~kname))]
               (cljs.core.logic/to-stream (map (fn [potential#]
                                   ((cljs.core.logic/== query# potential#)
                                    subs#))
                                 facts#)))))
         {:rel-name ~kname
          :indexes ~indexes}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro = [x y]
  &quot;Goal for testing whether x and y are equal. Non-relational.&quot;
  `(fn [a#]
     (let [wx# (cljs.core.logic.protocols/walk a# ~x)
           wy# (cljs.core.logic.protocols/walk a# ~y)]
       (if (clojure.core/= wx# wy#)
         a# nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro &gt; [x y]
  &quot;Goal for testing whether x is greater than y. Non-relational.&quot;
  `(fn [a#]
     (let [wx# (cljs.core.logic.protocols/walk a# ~x)
           wy# (cljs.core.logic.protocols/walk a# ~y)]
       (if (clojure.core/&gt; wx# wy#)
         a# nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro &gt;= [x y]
  &quot;Goal for testing whether x is greater than or equal to y.
  Non-relational.&quot;
  `(fn [a#]
     (let [wx# (cljs.core.logic.protocols/walk a# ~x)
           wy# (cljs.core.logic.protocols/walk a# ~y)]
       (if (clojure.core/&gt;= wx# wy#)
         a# nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro &lt; [x y]
  &quot;Goal for testing whether x is less than y. Non-relational.&quot;
  `(fn [a#]
     (let [wx# (cljs.core.logic.protocols/walk a# ~x)
           wy# (cljs.core.logic.protocols/walk a# ~y)]
       (if (clojure.core/&lt; wx# wy#)
         a# nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro &lt;= [x y]
  &quot;Goal for testing whether x is less than or equal to y.
  Non-relational.&quot;
  `(fn [a#]
     (let [wx# (cljs.core.logic.protocols/walk a# ~x)
           wy# (cljs.core.logic.protocols/walk a# ~y)]
       (if (clojure.core/&lt;= wx# wy#)
         a# nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -&gt;lcons
  ([env [m :as c] i] (-&gt;lcons env c i false))
  ([env [m :as c] i quoted]
     (cond
      (empty? c) `(fresh []
                    (cljs.core.logic/== ~(env (dec i)) ~(env i)))
      :else (let [m (if quoted `(quote ~m) m)]
              `(cljs.core.logic/== ~(env (dec i))
                                   (cljs.core.logic/lcons ~m ~(env i)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lsym [n]
  (gensym (str &quot;l&quot; n &quot;_&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn !dcg? [clause]
  (and (sequential? clause)
       (let [f (first clause)]
         (and (symbol? f)
              (identical? (name f) &quot;!dcg&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fresh-expr? [clause]
  (and (seq? clause)
       (let [f (first clause)]
         (and (symbol? f)
              (identical? (name f) &quot;fresh&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn mark-clauses
  ([cs] (mark-clauses cs (atom 0)))
  ([[c &amp; r :as cs] i]
     (cond
      (nil? (seq cs)) ()
      (fresh-expr? c) (cons `(fresh ~(second c)
                               ~@(mark-clauses (drop 2 c) i))
                            (mark-clauses r i))
      (!dcg? c) (cons c (mark-clauses r i))
      :else (cons (with-meta c
                    {:index (swap! i clojure.core/inc)})
                  (mark-clauses r i)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -handle-clauses [env [c &amp; r :as cs]]
  (cond
   (nil? (seq cs)) ()
   (fresh-expr? c) (cons `(fresh ~(second c)
                            ~@(-handle-clauses env (drop 2 c)))
                         (-handle-clauses env r))
   (!dcg? c) (cons (second c) (-handle-clauses env r))
   (vector? c) (cons (-&gt;lcons env c (-&gt; c meta :index))
                     (-handle-clauses env r))
   (and (seq? c)
        (clojure.core/= (first c) 'quote)
        (vector? (second c))) (cons (-&gt;lcons env (second c)
                                             (-&gt; c meta :index) true)
                                    (-handle-clauses env r))
        :else (let [i (-&gt; c meta :index)
                    c (if (seq? c) c (list c))]
                (cons (concat c [(env (dec i)) (env i)])
                      (-handle-clauses env r)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare count-clauses)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn handle-cclause [fsym osym cclause]
  (let [c (count-clauses cclause)
        r (range 2 (clojure.core/inc c))
        lsyms (conj (into [fsym] (map lsym r)) osym)
        clauses (mark-clauses cclause)
        clauses (-handle-clauses lsyms clauses)]
    `(fresh [~@(butlast (rest lsyms))]
       ~@clauses)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro --&gt;e [name &amp; cclauses]
  (let [fsym (gensym &quot;l1_&quot;)
        osym (gensym &quot;o&quot;)]
    `(defn ~name [~fsym ~osym]
       (conde
        ~@(map list (map (partial handle-cclause fsym osym) cclauses))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro def--&gt;e [name args &amp; pcss]
  (let [fsym (gensym &quot;l1_&quot;)
        osym (gensym &quot;o&quot;)]
    `(defne ~name [~@args ~fsym ~osym]
       ~@(map (fn [[p &amp; cs]]
                (list (-&gt; p (conj '_) (conj '_))
                      (handle-cclause fsym osym cs)))
              pcss))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro --&gt; [name &amp; clauses]
  (let [r (range 1 (+ (count-clauses clauses) 2))
        lsyms (into [] (map lsym r))
        clauses (mark-clauses clauses)
        clauses (-handle-clauses lsyms clauses)]
    `(defn ~name [~(first lsyms) ~(last lsyms)]
       (fresh [~@(butlast (rest lsyms))]
         ~@clauses))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn count-clauses [clauses]
  (if (fresh-expr? clauses)
    (count-clauses (drop 2 clauses))
    (reduce (fn [s c]
              (cond
               (fresh-expr? c) (+ s (count-clauses (drop 2 c)))
               (!dcg? c) s
               :else (clojure.core/inc s)))
            0 clauses)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro def--&gt; [name args &amp; clauses]
  (let [r (range 1 (+ (count-clauses clauses) 2))
        lsyms (map lsym r)
        clauses (mark-clauses clauses)
        clauses (-handle-clauses lsyms clauses)]
    `(defn ~name [~@args ~(first lsyms) ~(last lsyms)]
       (fresh [~@(butlast (rest lsyms))]
         ~@clauses))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.nominal.macros" name="cljs.core.logic.nominal.macros"><h1 class="project-name">cljs.core.logic.nominal.macros</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.nominal.macros
  (:require [cljs.core.logic.macros :as m]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- nom-bind [sym]
  ((juxt identity
         (fn [s] `(cljs.core.logic.nominal/nom
                   (cljs.core.logic/lvar '~s)))) sym))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- nom-binds [syms]
  (mapcat nom-bind syms))</pre></td></tr><tr><td class="docs"><p>Creates fresh noms. Goals occuring within form a logical conjunction.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro fresh
  [[&amp; noms] &amp; goals]
  `(fn [a#]
     (cljs.core.logic.macros/-inc
      (let [~@(nom-binds noms)]
        (cljs.core.logic.macros/bind* a# ~@goals)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic" name="cljs.core.logic"><h1 class="project-name">cljs.core.logic</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic
  (:refer-clojure :exclude [==])
  (:require [clojure.set :as set]
            [clojure.string :as string]
            [cljs.core.logic.protocols :as proto
             :refer [walk non-storable? reifiable? enforceable?
                     tree-constraint? take* unify-terms ext-no-check id bind
                     lfirst lnext ifa -cached? -add reify-tabled
                     -reify-tabled reuse ready? subunify
                     unify-with-record unify-with-pmap -member-count]]
            [cljs.reader :as reader])
  (:require-macros [cljs.core.logic.macros
                    :refer [umi uai llist composeg* bind* mplus* -inc
                            conde fresh -run run run* run-db run-db* run-nc
                            run-nc* all is pred project trace-lvars trace-s
                            log ifa* ifu* conda condu lvaro nonlvaro fnm
                            defnm fne defne matche fna fnu defna defnu matcha
                            matchu tabled let-dom fnc defnc]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *logic-dbs* [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def fk (js/Error.))</pre></td></tr><tr><td class="docs"><p>Utilities</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn assoc-meta [x k v]
  (with-meta x (assoc (meta x) k v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn dissoc-meta [x k]
  (with-meta x (dissoc (meta x) k)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn assoc-dom [x k v]
  (assoc x :doms (assoc (.-doms x) k v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn dissoc-dom [x k]
  (assoc x :doms (dissoc (.-doms x) k)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean record? [x]
  (satisfies? IRecord x))</pre></td></tr><tr><td class="docs"><p>Pair</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype Pair [lhs rhs]
  Object
  (toString [_]
    (str &quot;(&quot; lhs &quot; . &quot; rhs &quot;)&quot;))
  ILookup
  (-lookup [this k]
    (-lookup this k nil))
  (-lookup [this k not-found]
    (case k
      :lhs lhs
      :rhs rhs
      not-found))
  ICounted
  (-count [_] 2)
  IIndexed
  (-nth [this i]
    (case i
      0 lhs
      1 rhs
      (throw (ex-info &quot;Index out of bounds&quot; {:index i :coll this}))))
  (-nth [_ i not-found]
    (case i
      0 lhs
      1 rhs
      not-found))
  IMapEntry
  (-key [_] lhs)
  (-val [_] rhs)
  IEquiv
  (-equiv [_ o]
    (if (instance? Pair o)
      (and (= lhs (.-lhs o))
           (= rhs (.-rhs o)))
      false))
  IPrintWithWriter
  (-pr-writer [x writer opts]
    (-write writer (str &quot;(&quot; (.-lhs x) &quot; . &quot; (.-rhs x) &quot;)&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pair [lhs rhs]
  (Pair. lhs rhs))</pre></td></tr><tr><td class="docs"><p>Constraint Store</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare lvar? bindable? add-var)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn var-rands [a c]
  (-&gt;&gt; (proto/-rands c)
       (map #(proto/root-var a %))
       (filter lvar?)
       (into [])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unbound-rands [a c]
  (-&gt;&gt; (var-rands a c)
       (filter #(lvar? (proto/root-val a %)))))</pre></td></tr><tr><td class="docs"><h2>ConstraintStore</h2>

<p>km  - mapping logic vars to constraints ids
cm  - mapping constraint ids to to actual constraints
cid - the current constraint id, an integer, incremented
      everytime we add a constraint to the store
running - set of running constraint ids</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype ConstraintStore [km cm cid running]
  ILookup
  (-lookup [this k]
    (-lookup this k nil))
  (-lookup [this k not-found]
    (case k
      :km km
      :cm cm
      :cid cid
      :running running
      not-found))
  proto/IConstraintStore
  (addc [this a c]
    (let [vars (var-rands a c)
          c (proto/with-id c cid)
          cs (reduce (fn [cs v] (add-var cs v c)) this vars)]
      (ConstraintStore. (.-km cs) (.-cm cs) (inc cid) running)))
  (updatec [this a c]
    (let [oc (cm (id c))
          nkm (if (satisfies? cljs.core.logic.protocols.IEntailedVar c)
                (reduce (fn [km x]
                          (if (proto/-entailed-var? c x)
                            (dissoc km x)
                            km))
                        km (var-rands a oc))
                km)]
      (ConstraintStore. nkm (assoc cm (id c) c) cid running)))
  (remc [this a c]
    (let [vs (var-rands a c)
          ocid (id c)
          nkm (reduce (fn [km v]
                        (let [vcs (disj (get km v) ocid)]
                          (if (empty? vcs)
                            (dissoc km v)
                            (assoc km v vcs))))
                      km vs)
          ncm (dissoc cm ocid)]
      (ConstraintStore. nkm ncm cid running)))
  (runc [this c state]
    (if state
      (ConstraintStore. km cm cid (conj running (id c)))
      (ConstraintStore. km cm cid (disj running (id c)))))
  (constraints-for [this a x ws]
    (when-let [ids (get km (proto/root-var a x))]
      (filter #((proto/-watched-stores %) ws) (map cm (remove running ids)))))
  (migrate [this x root]
    (let [xcs    (km x)
          rootcs (km root #{})
          nkm    (assoc (dissoc km x) root (into rootcs xcs))]
      (ConstraintStore. nkm cm cid running)))
  ICounted
  (-count [this] (count cm)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-var [cs x c]
  (when-not (lvar? x)
    (throw (ex-info
            (str &quot;constraint store assoc expected logic var key: &quot; x) {})))
  (let [cm (.-cm cs)
        km (.-km cs)
        cid (.-cid cs)
        nkm (update-in km [x] (fnil (fn [s] (conj s cid)) #{}))
        ncm (assoc cm cid c)]
    (ConstraintStore. nkm ncm cid (.-running cs))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-cs []
  (ConstraintStore. {} {} 0 #{}))</pre></td></tr><tr><td class="docs"><p>=======================================================================
SubstValue
v - the actual ground value of the var
doms - the constraint domains assigned to the var
eset - set of other vars this var is entangled with</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SubstValue [v doms eset]
  Object
  (toString [_] (str v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean subst-val? [x]
  (instance? SubstValue x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn subst-val
  ([x] (SubstValue. x nil nil))
  ([x doms] (SubstValue. x doms nil))
  ([x doms _meta] (with-meta (SubstValue. x doms nil) _meta))
  ([x doms eset _meta] (with-meta (SubstValue. x doms eset) _meta)))</pre></td></tr><tr><td class="docs"><p>==========================================================================
Substitutions</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare empty-s choice lvar lvar? pair lcons run-constraints*)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn occurs-check [s u v]
  (let [v (walk s v)]
    (proto/occurs-check-term v u s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ext [s u v]
  (if (and (.-oc s) ^boolean (occurs-check s u (if (subst-val? v) (.-v v) v)))
    nil
    (ext-no-check s u v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare tree-term?)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn walk* [s v]
  (let [v (walk s v)]
    (proto/walk-term v
                     (fn [x]
                       (let [x (walk s x)]
                         (if (tree-term? x)
                           (walk* s x)
                           x))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unify [s u v]
  (if (identical? u v)
    s
    (let [u (walk s u)
          v (walk s v)]      
      (if (and (lvar? u) (= u v))
        s
        (if (and (not (lvar? u)) (lvar? v))
          (proto/unify-terms v u s)
          (proto/unify-terms u v s))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def unbound-names
  (let [r (range 100)]
    (zipmap r (map (comp symbol str) (repeat &quot;_&quot;) r))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reify-lvar-name [s]
  (let [c (count s)]
    (if (&lt; c 100)
      (unbound-names c)
      (symbol (str &quot;_&quot; (count s))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -reify* [s v]
  (let [v (walk s v)]
    (proto/reify-term v s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -reify
  ([s v]
     (let [v (walk* s v)]
       (walk* ^not-native (-reify* (with-meta empty-s (meta s)) v) v)))
  ([s v r]
     (let [v (walk* s v)]
       (walk* ^not-native (-reify* r v) v))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn build [s u]
  (proto/build-term u s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare empty-s make-s)</pre></td></tr><tr><td class="docs"><h2>Substitutions</h2>

<p>s   - persistent hashmap to store logic var bindings
vs  - changed var set
ts  - atom containing a hashmap of
      tabled goals -> atoms of sets containing cached answers
cs  - constraint store
cq  - for the constraint queue
cqs - constraint ids in the queue
oc  - occurs check</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype Substitutions [s vs ts cs cq cqs oc _meta]
  Object
  (toString [_] (str s))
  IEquiv
  (-equiv [this o]
    (or (identical? this o)
        (and (instance? Substitutions o)
             (= s (.-s o)))))
  ICounted
  (-count [this] (count s))
  IMeta
  (-meta [this] _meta)
  IWithMeta
  (-with-meta [this new-meta]
    (Substitutions. s vs ts cs cq cqs oc new-meta))
  ILookup
  (-lookup [this k]
    (-lookup this k nil))
  (-lookup [this k not-found]
    (case k
      :s   s
      :vs  vs
      :ts  ts
      :cs  cs
      :cq  cq
      :cqs cqs
      :oc  oc
      not-found))
  ICollection
  (-conj [this [k v]]
    (if (lvar? k)
      (assoc this k v)
      (throw (ex-info (str &quot;key must be a logic var&quot;) {}))))
  IEmptyableCollection
  (-empty [this] empty-s)
  IAssociative
  (-contains-key? [this k]
    (contains? #{:s :vs :cs :cq :cqs :oc} k))
  (-assoc [this k v]
    (case k
      :s   (Substitutions. v vs ts cs cq cqs oc _meta)
      :vs  (Substitutions. s  v ts cs cq cqs oc _meta)
      :ts  (Substitutions. s vs  v cs cq cqs oc _meta)
      :cs  (Substitutions. s vs ts  v cq cqs oc _meta)
      :cq  (Substitutions. s vs ts cs  v cqs oc _meta)
      :cqs (Substitutions. s vs ts cs cq   v oc _meta)
      :oc  (Substitutions. s vs ts cs cq cqs  v _meta)
      (throw (ex-info (str &quot;Substitutions has no field for key&quot; k) {}))))
  proto/ISubstitutions
  (ext-no-check [this u v]
    (let [u (if-not (lvar? v)
              (assoc-meta u ::root true)
              u)]
      (Substitutions. (assoc s u v)
                      (if vs (conj vs u)) ts cs cq cqs oc _meta)))
  (walk [this v]
    (if (bindable? v)
      (loop [lv v me (find s v)]
        (if (nil? me)
          lv
          (let [v  (key me)
                vp (val me)]
            (if (not (bindable? vp))
              (if (subst-val? vp)
                (let [sv (.-v vp)]
                  (if (keyword-identical? sv ::unbound)
                    (with-meta v (assoc (meta vp) ::unbound true))
                    sv))
                vp)
              (recur vp (find s vp))))))
      v))
  proto/ISubstitutionsCLP
  (root-val [this v]
    (if (lvar? v)
      (loop [lv v [v vp :as me] (find s v)]
        (cond
         (nil? me) lv
         (not (lvar? vp)) vp
         :else (recur vp (find s vp))))
      v))
  (root-var [this v]
    (if (lvar? v)
      (if (-&gt; v meta ::root)
        v
        (loop [lv v [v vp :as me] (find s v)]
          (cond
           (nil? me) lv
           (not (lvar? vp))
           (if (subst-val? vp)
             (with-meta v (meta vp))
             v)
           :else (recur vp (find s vp)))))
      v))
  (ext-run-cs [this x v]
    (let [x  (proto/root-var this x)
          xs (if (lvar? v)
               [x (proto/root-var this v)]
               [x])
          s  (if oc
               (ext this x v)
               (ext-no-check this x v))]
      (when s
        ((run-constraints* xs cs ::subst) s))))
  (queue [this c]
    (let [id (id c)]
      (if-not (cqs id)
        (-&gt; this
            (assoc :cq (conj (or cq []) c))
            (assoc :cqs (conj cqs id)))
        this)))
  (update-var [this x v]
    (assoc this :s (assoc (.-s this) x v)))
  proto/IBind
  (bind [this g]    
    (g this))
  proto/IMPlus
  (mplus [this f]
    (choice this f))
  proto/ITake
  (take* [this] this))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-attr [s x attr attrv]
  (let [x (proto/root-var s x)
        v (proto/root-val s x)]
    (if (subst-val? v)
      (proto/update-var s x (assoc-meta v attr attrv))
      (let [v (if (lvar? v) ::unbound v)]
        (ext-no-check s x (with-meta (subst-val v) {attr attrv}))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rem-attr [s x attr]
  (let [x (proto/root-var s x)
        v (proto/root-val s x)]
    (if (subst-val? v)
      (let [new-meta (dissoc (meta v) attr)]
        (if (and (zero? (count new-meta)) (not= (.-v v) ::unbound))
          (proto/update-var s x (.-v v))
          (proto/update-var s x (with-meta v new-meta))))
      s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-attr [s x attr]
  (let [v (proto/root-val s x)]
    (if (subst-val? v)
      (-&gt; v meta attr))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sync-eset [s v seenset f]
  (if (not= seenset ::no-prop)
    (reduce
     (fn [s y]
       (let [y (proto/root-var s y)]
         (if-not (contains? seenset y)
           (f s y)
           s)))
     s
     (.-eset v))
    s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-dom
  ([s x dom domv]
     (let [x (proto/root-var s x)]
       (add-dom s x dom domv nil)))
  ([s x dom domv seenset]
     (let [v (proto/root-val s x)
           s (if (subst-val? v)
               (proto/update-var s x (assoc-dom v dom domv))
               (let [v (if (lvar? v) ::unbound v)]
                 (ext-no-check s x (subst-val v {dom domv}))))]
       (sync-eset s v seenset
                  (fn [s y]
                    (add-dom s y dom domv (conj (or seenset #{}) x)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn update-dom
  ([s x dom f]
     (let [x (proto/root-var s x)]
       (update-dom s x dom f nil)))
  ([s x dom f seenset]
     (let [v (proto/root-val s x)
           v (if (lvar? v)
               (subst-val ::unbound)
               v)
           doms (.-doms v)
           s (proto/update-var s x (assoc-dom v dom (f (get doms dom))))]
       (sync-eset s v seenset
                  (fn [s y]
                    (update-dom s y dom f (conj (or seenset #{}) x)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rem-dom
  ([s x dom]
     (let [x (proto/root-var s x)]
       (rem-dom s x dom nil)))
  ([s x dom seenset]
     (let [v (proto/root-val s x)
           s (if (subst-val? v)
               (let [new-doms (dissoc (.-doms v) dom)]
                 (if (and (zero? (count new-doms)) (not= (.-v v) ::unbound))
                   (proto/update-var s x (.-v v))
                   (proto/update-var s x (assoc v :doms new-doms))))
               s)]
       (sync-eset s v seenset
                  (fn [s y] (rem-dom s y dom (conj (or seenset #{}) x)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-dom [s x dom]
  (let [v (proto/root-val s x)]
    (cond
     (subst-val? v) (let [v' (.-v v)]
                      (if (not= v' ::unbound)
                        v'
                        (-&gt; v :doms dom)))
     (not (lvar? v)) v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- make-s
  ([] (make-s {}))
  ([m] (make-s m (make-cs)))
  ([m cs] (Substitutions. m nil nil cs nil #{} true nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn tabled-s
  ([] (tabled-s false))
  ([oc] (tabled-s oc nil))
  ([oc meta]
     (-&gt; (with-meta (make-s) meta)
         (assoc :oc oc)
         (assoc :ts (atom {})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^not-native empty-s (make-s))
(def empty-f (fn []))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean subst? [x]
  (instance? Substitutions x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn to-s [v]
  (let [s (reduce (fn [m [k v]] (assoc m k v)) {} v)]
    (make-s s (make-cs))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn annotate [k v]
  (fn [a]
    (vary-meta a assoc k v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn merge-doms [s x doms]
  (let [xdoms (.-doms (proto/root-val s x))]
    (loop [doms (seq doms) s s]
      (if doms
        (let [[dom domv] (first doms)]
          (let [xdomv (get xdoms dom ::not-found)
                ndomv (if (keyword-identical? xdomv ::not-found)
                        domv
                        (proto/-merge-doms domv xdomv))]
            (when ndomv
              (recur (next doms)
                     (add-dom s x dom ndomv #{})))))
        s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn update-eset [s doms eset]
  (loop [eset (seq eset) s s]
    (if eset
      (when-let [s (merge-doms s (proto/root-var s (first eset)) doms)]
        (recur (next eset) s))
      s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn merge-with-root [s x root]
  (let [xv    (proto/root-val s x)
        rootv (proto/root-val s root)
        eset  (set/union (.-eset rootv) (.-eset xv))
        doms (loop [xd (seq (.-doms xv)) rd (.-doms rootv) r {}]
               (if xd
                 (let [[xk xv] (first xd)]
                   (if-let [[_ rv] (find rd xk)]
                     (let [nd (proto/-merge-doms xv rv)]
                       (when nd
                         (recur (next xd)
                                (dissoc rd xk) (assoc r xk nd))))
                     (recur (next xd) rd (assoc r xk xv))))
                 (merge r rd)))
        nv (when doms
             (subst-val (.-v rootv) doms eset
                        (merge (meta xv) (meta rootv))))]
    (when nv
      (-&gt; s
          (ext-no-check root nv)
          (update-eset doms eset)))))</pre></td></tr><tr><td class="docs"><p>==========================================================================
Entanglement</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn to-subst-val [v]
  (if (subst-val? v)
    v
    (subst-val ::unbound)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn entangle [s x y]
  (let [x  (proto/root-var s x)
        y  (proto/root-var s y)
        xv (to-subst-val (proto/root-val s x))
        yv (to-subst-val (proto/root-val s y))]
    (-&gt; s
        (proto/update-var x (assoc xv :eset (conj (or (.-eset xv) #{}) y)))
        (proto/update-var y (assoc yv :eset (conj (or (.-eset yv) #{}) x))))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Logic Variables</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype LVar [id unique name oname hash meta]
  proto/IVar
  ILookup
  (-lookup [this k]
    (-lookup this k nil))
  (-lookup [this k not-found]
    (case k
      :name name
      :oname oname
      :id id
      not-found))
  IMeta
  (-meta [this] meta)
  IWithMeta
  (-with-meta [this new-meta]
    (LVar. id unique name oname hash new-meta))
  Object
  (toString [_] (str &quot;&lt;lvar:&quot; name &quot;&gt;&quot;))
  IEquiv
  (-equiv [this o]
    (if (satisfies? proto/IVar o)
      (if unique
        (identical? id (.-id o))
        (identical? name (.-name o)))
      false))
  IHash
  (-hash [_] hash)
  proto/IUnifyTerms
  (unify-terms [u v ^not-native s]
    (cond
     (lvar? v)
     (let [repoint (cond
                    (-&gt; u clojure.core/meta ::unbound) [u v]
                    (-&gt; v clojure.core/meta ::unbound) [v u]
                    :else nil)]
       (if repoint
         (let [[root other] repoint
               s (assoc s :cs (proto/migrate (.-cs s) other root))
               s (if (-&gt; other clojure.core/meta ::unbound)
                   (merge-with-root s other root)
                   s)]
           (when s
             (ext-no-check s other root)))
         (ext-no-check s u v)))
     (non-storable? v)
     (throw (ex-info (str v &quot; is non-storable&quot;) {}))
     (not= v ::not-found)
     (if (tree-term? v)
       (ext s u v)
       (if (-&gt; u clojure.core/meta ::unbound)
         (ext-no-check s u (assoc (proto/root-val s u) :v v))
         (ext-no-check s u v)))
     :else nil))
  proto/IReifyTerm
  (reify-term [v ^not-native s]
    (let [rf (-&gt; s clojure.core/meta :reify-vars)]
      (if (fn? rf)
        (rf v s)
        (if rf
          (ext s v (reify-lvar-name s))
          (ext s v (.-oname v))))))
  proto/IWalkTerm
  (walk-term [v f]
    (f v))
  proto/IOccursCheckTerm
  (occurs-check-term [v x ^not-native s] (= (walk s v) x))
  proto/IBuildTerm
  (build-term [u ^not-native s]
    (let [m (.-s s)
          cs (.-cs s)
          lv (lvar 'ignore)]
      (if (contains? m u)
        s
        (make-s (assoc m u lv) cs))))
  IPrintWithWriter
  (-pr-writer [x writer opts]
    (-write writer (str &quot;&lt;lvar:&quot; (.-name x) &quot;&gt;&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn next-id
  []
  (-&gt; (str (gensym))
      (clojure.string/replace #&quot;G__&quot; )
      reader/read-string))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lvar
  ([]
     (let [id (next-id)
           name (str id)]
       (LVar. id true name nil (hash name) nil)))
  ([name]
     (lvar name true))
  ([name unique]
     (let [oname name
           id   (if unique
                  (next-id)
                  name)
           name (if unique
                  (str name &quot;__&quot; id)
                  (str name))]
       (LVar. id unique name oname (hash name) nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean lvar? [x]
  (satisfies? proto/IVar x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lvars [n]
  (repeatedly n lvar))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean bindable? [x]
  (or (lvar? x)
      (satisfies? proto/IBindable x)))</pre></td></tr><tr><td class="docs"><p>==========================================================================
LCons</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare lcons?)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype LCons [a d ^:unsynchronized-mutable cache meta]
  proto/ITreeTerm  
  IMeta
  (-meta [this] meta)
  IWithMeta
  (-with-meta [this new-meta]
    (LCons. a d cache new-meta))
  proto/LConsSeq
  (lfirst [_] a)
  (lnext [_] d)
  proto/LConsPrint
  (toShortString [this]
    (cond
     (instance? LCons d) (str a &quot; &quot; (proto/toShortString d))
     :else (str a &quot; . &quot; d)))
  Object
  (toString [this] (cond
                    (instance? LCons d)
                    (str &quot;(&quot; a &quot; &quot; (proto/toShortString d) &quot;)&quot;)
                    :else (str &quot;(&quot; a &quot; . &quot; d &quot;)&quot;)))
  IEquiv
  (-equiv [this o]
    (or (identical? this o)
        (and (instance? LCons o)
             (loop [me this
                    you o]
               (cond
                (nil? me) (nil? you)
                (lvar? me) true
                (lvar? you) true
                (and (lcons? me) (lcons? you))
                (let [mef  (lfirst me)
                      youf (lfirst you)]
                  (and (or (= mef youf)
                           (lvar? mef)
                           (lvar? youf))
                       (recur (lnext me) (lnext you))))
                :else (= me you))))))
  IHash
  (-hash [this]
    (if (cljs.core/== cache -1)
      (do
        (set! cache (uai (umi (int 31) (hash d))
                         (hash a)))
        cache)
      cache))
  proto/IUnifyTerms
  (unify-terms [^not-native u ^not-native v ^not-native s]
    (cond
     (sequential? v)
     (loop [u u v (seq v) s s]
       (if-not (nil? v)
         (if (lcons? u)
           (if-let [s (unify s (lfirst u) (first v))]
             (recur (lnext u) (next v) s)
             nil)
           (unify s u v))
         (if (lvar? u)
           (if-let [s (unify s u '())]
             s
             (unify s u nil))
           nil)))
     (lcons? v)
     (loop [u u v v s s]
       (if (lvar? u)
         (unify s u v)
         (cond
          (lvar? v) (unify s v u)
          (and (lcons? u) (lcons? v))
          (if-let [s (unify s (lfirst u) (lfirst v))]
            (recur (lnext u) (lnext v) s)
            nil)
          :else (unify s u v))))
     :else nil))
  proto/IReifyTerm
  (reify-term [v s]    
    (loop [v v s s]
      (if (lcons? v)
        (recur (lnext v) (-reify* s (lfirst v)))
        (-reify* s v))))
  proto/IWalkTerm
  (walk-term [v f]
    (lcons (f (lfirst v))
           (f (lnext v))))
  proto/IOccursCheckTerm
  (occurs-check-term [v x ^not-native s]
    (loop [v v x x s s]
      (if (lcons? v)
        (or (occurs-check s x (lfirst v))
            (recur (lnext v) x s))
        (occurs-check s x v))))
  proto/IBuildTerm
  (build-term [u s]
    (loop [u u s s]
      (if (lcons? u)
        (recur (lnext u) (build s (lfirst u)))
        (build s u))))
  IPrintWithWriter
  (-pr-writer [x writer opts]
    (-write writer (str x))))</pre></td></tr><tr><td class="docs"><p>Constructs a sequence a with an improper tail d if d is a logic variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defn lcons
  [a d]
  (if (or (coll? d) (nil? d))
    (cons a (seq d))
    (LCons. a d -1 nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean lcons? [x]
  (instance? LCons x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean tree-term? [x]
  (or (coll? x)
      (satisfies? proto/ITreeTerm x)))</pre></td></tr><tr><td class="docs"><p>==========================================================================
Unification</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unify-with-sequential* [^not-native u ^not-native v ^not-native s]
  (cond
   (sequential? v)
   (if (and (counted? u) (counted? v)
            (not (= (count u) (count v))))
     nil
     (loop [^not-native u (-seq u) ^not-native v (-seq v) s s]
       (if-not (nil? u)
         (if-not (nil? v)
           (if-let [s (unify s (first u) (first v))]
             (recur (next u) (next v) s)
             nil)
           nil)
         (if-not (nil? v) nil s))))
   (lcons? v) (unify-terms v u s)
   :else nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unify-with-map* [u v s]
  (when (= (count u) (count v))
    (loop [ks (keys u) s s]
      (if (seq ks)
        (let [kf (first ks)
              vf (get v kf ::not-found)]
          (when-not (keyword-identical? vf ::not-found)
            (if-let [s (unify s (get u kf) vf)]
              (recur (next ks) s)
              nil)))
        s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IUnifyTerms
  nil
  (unify-terms [u v s]
    (if (nil? v) s nil))

  default
  (unify-terms [u v s]
    (cond
     (sequential? u)
     (unify-with-sequential* u v s)
     (map? u)
     (cond
      (satisfies? proto/IUnifyWithRecord v)
      (unify-with-record v u s)

      (map? v)
      (unify-with-map* u v s)

      :else nil)
     :else (if (= u v)
             s
             nil))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Reification</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IReifyTerm
  nil
  (reify-term [v s] s)

  default
  (reify-term [v ^not-native s]
    (cond (coll? v)
          (loop [v v s s]
            (if (seq v)
              (recur (next v) (-reify* s (first v)))
              s))
          :else s)))</pre></td></tr><tr><td class="docs"><p>==========================================================================
Walk Term</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn walk-record-term [v f]
  (with-meta
    (loop [v v r (proto/-uninitialized v)]
      (if (seq v)
        (let [[vfk vfv] (first v)]
          (recur (next v) (assoc r (proto/walk-term (f vfk) f)
                                 (proto/walk-term (f vfv) f))))
        r))
    (meta v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn walk-term-map*
  [^not-native v f]
  (with-meta
    (loop [^not-native v v ^not-native r (transient {})]
      (if (seq v)
        (let [[vfk vfv] (first v)]
          (recur (next v) (assoc! r (proto/walk-term (f vfk) f)
                                  (proto/walk-term (f vfv) f))))
        (persistent! r)))
    (meta v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IWalkTerm
  nil
  (walk-term [v f] (f nil))

  default
  (walk-term [v f]
    (cond (seq? v)
          (with-meta
            (doall (map #(proto/walk-term (f %) f) v))
            (meta v))
          (record? v)
          (walk-record-term v f)
          :else (f v)))

  PersistentHashMap
  (walk-term [v f] (walk-term-map* v f))

  PersistentArrayMap
  (walk-term [v f] (walk-term-map* v f))

  PersistentVector
  (walk-term [v f]
    (with-meta
      (loop [v v ^not-native r (transient [])]
        (if (seq v)
          (recur (next v) (conj! r (proto/walk-term (f (first v)) f)))
          (persistent! r)))
      (meta v))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Occurs Check Term</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IOccursCheckTerm
  nil
  (occurs-check-term [v x s] false)

  default
  (occurs-check-term [v x s]
    (cond (coll? v)
          (loop [v v x x s s]
            (if (seq v)
              (or (occurs-check s x (first v))
                  (recur (next v) x s))
              false))
          :else false)))</pre></td></tr><tr><td class="docs"><p>==========================================================================
Build Term</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IBuildTerm
  nil
  (build-term [u s] s)

  default
  (build-term [u s]
    (cond (coll? u)
          (reduce build s u)
          :else s)))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Goals and Goal Constructors</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn composeg
  ([] identity)
  ([g0 g1]
     (fn [a]
       (let [a (g0 a)]
         (and a (g1 a))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype Choice [a f]
  ILookup
  (-lookup [this k]
    (-lookup this k nil))
  (-lookup [this k not-found]
    (case k
      :a a
      not-found))
  proto/IBind
  (bind [this g]
    (proto/mplus (g a) (fn [] (proto/bind f g))))
  proto/IMPlus
  (mplus [this fp]
    (Choice. a (fn [] (proto/mplus (fp) f))))
  proto/ITake
  (take* [this]
    (lazy-seq (cons a (lazy-seq (take* f))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn choice [a f]
  (Choice. a f))</pre></td></tr><tr><td class="docs"><p><hr />
MZero</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type nil
  proto/IBind
  (bind [_ g] nil)
  proto/IMPlus
  (mplus [_ f] (f))
  proto/ITake
  (take* [_] '()))</pre></td></tr><tr><td class="docs"><p><hr />
Unit and Inc</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IBind
  default
  (bind [this g]
    (cond (fn? this) (-inc (proto/bind (this) g))
          :else (throw (ex-info &quot;No protocol method&quot; {})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IMPlus
  default
  (mplus [this f]
    (cond (fn? this) (-inc (proto/mplus (f) this))
          :else (Choice. this f))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/ITake
  default
  (take* [this]
    (cond (fn? this)
          (lazy-seq (proto/take* (this)))
          :else this)))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Syntax</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A goal that always succeeds.</p>
</td><td class="codes"><pre class="brush: clojure">(defn succeed
  [a] a)</pre></td></tr><tr><td class="docs"><p>A goal that always fails.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fail
  [a] nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def s# succeed)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def u# fail)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ext-run-csg [u v]
  (fn [a]
    (proto/ext-run-cs a u v)))</pre></td></tr><tr><td class="docs"><p>A goal that attempts to unify terms u and v.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ==
  [u v]
  (fn [a]
    (let [has-cs? (pos? (count (.-cs a)))]
      (let [ap (unify (if has-cs? (assoc a :vs []) a) u v)
            vs (if has-cs? (:vs ap))
            changed? (pos? (count vs))]
        (if changed?
          ((run-constraints* vs (.-cs ap) ::subst) (assoc ap :vs nil))
          ap)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare reifyg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn solutions
  ([s g]
     (solutions s (lvar) g))
  ([s q g]
     (proto/take* ((all g (reifyg q)) s))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
conda (soft-cut), condu (committed-choice)</p>

<p>conda once a line succeeds no others are tried
condu a line can succeed only one time</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TODO : conda and condu should probably understanding logging</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TODO : if -> when</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IIfA
  nil
  (ifa [b gs c]
    (when c
      (force c)))

  Substitutions
  (ifa [b gs c]
    (reduce bind b gs))

  default
  (ifa [b gs c]
    (cond (fn? b) (-inc (ifa (b) gs c))
          :else nil))

  Choice
  (ifa [b gs c]
    (reduce bind b gs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IIfU
  nil
  (ifu [b gs c]
    (when c
      (force c)))

  Substitutions
  (ifu [b gs c]
    (reduce bind b gs))

  default
  (ifu [b gs c]
    (cond (fn? b) (-inc (proto/ifu (b) gs c))
          :else nil))

  Choice
  (ifu [b gs c]
    (reduce bind (.-a b) gs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn onceo [g] (condu (g)))</pre></td></tr><tr><td class="docs"><p>==========================================================================
copy-term</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Copies a term u into v. Non-relational.</p>
</td><td class="codes"><pre class="brush: clojure">(defn copy-term
  [u v]
  (project [u]
    (== (walk* (build empty-s u) u) v)))</pre></td></tr><tr><td class="docs"><p>==========================================================================
Useful goals</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A relation where a is nil</p>
</td><td class="codes"><pre class="brush: clojure">(defn nilo
  [a]
  (== nil a))</pre></td></tr><tr><td class="docs"><p>A relation where a is the empty list</p>
</td><td class="codes"><pre class="brush: clojure">(defn emptyo
  [a]
  (== '() a))</pre></td></tr><tr><td class="docs"><p>A relation where l is a collection, such that a is the first of l
  and d is the rest of l. If ground d must be bound to a proper tail.</p>
</td><td class="codes"><pre class="brush: clojure">(defn conso
  [a d l]
  (== (lcons a d) l))</pre></td></tr><tr><td class="docs"><p>A relation where l is a collection, such that a is the first of l</p>
</td><td class="codes"><pre class="brush: clojure">(defn firsto
  [l a]
  (fresh [d]
    (conso a d l)))</pre></td></tr><tr><td class="docs"><p>A relation where l is a collection, such that d is the rest of l</p>
</td><td class="codes"><pre class="brush: clojure">(defn resto
  [l d]
  (fresh [a]
    (== (lcons a d) l)))</pre></td></tr><tr><td class="docs"><p>A pseudo-relation that takes a coll and ensures that the goal g
   succeeds on every element of the collection.</p>
</td><td class="codes"><pre class="brush: clojure">(defn everyg
  [g coll]
  (fn [a]
    (let [coll (walk a coll)]
      (((fn everyg* [g coll]
          (if (seq coll)
            (all
             (g (first coll))
             (everyg* g (next coll)))
            s#)) g coll) a))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
More convenient goals</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare !=)</pre></td></tr><tr><td class="docs"><p>A relation where l is a collection, such that l contains x.</p>
</td><td class="codes"><pre class="brush: clojure">(defne membero
  [x l]
  ([_ [x . tail]])
  ([_ [head . tail]]
     (membero x tail)))</pre></td></tr><tr><td class="docs"><p>Like membero but uses to disequality further constraining
   the results. For example, if x and l are ground and x occurs
   multiple times in l, member1o will succeed only once.</p>
</td><td class="codes"><pre class="brush: clojure">(defne member1o
  [x l]
  ([_ [x . tail]])
  ([_ [head . tail]]
     (!= x head)
     (member1o x tail)))</pre></td></tr><tr><td class="docs"><p>A relation where x, y, and z are proper collections,
  such that z is x appended to y</p>
</td><td class="codes"><pre class="brush: clojure">(defne appendo
  [x y z]
  ([() _ y])
  ([[a . d] _ [a . r]] (appendo d y r)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare rembero)</pre></td></tr><tr><td class="docs"><p>A relation that will permute xl into the yl. May not
   terminate if xl is not ground.</p>
</td><td class="codes"><pre class="brush: clojure">(defne permuteo
  [xl yl]
  ([() ()])
  ([[x . xs] _]
     (fresh [ys]
       (permuteo xs ys)
       (rembero x yl ys))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Rel</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn to-stream [aseq]
  (let [aseq (drop-while nil? aseq)]
    (when (seq aseq)
      (choice (first aseq)
              (fn [] (to-stream (next aseq)))))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Tabling</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>See - William Byrd "Relational Programming in miniKanren:
Techniques, Applications, and Implementations"
http://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd<em>indiana</em>0093A_10344.pdf?sequence=1
http://code.google.com/p/iucs-relational-research/</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p><hr />
Data Structures
waiting streams are PersistentVectors</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>AnswerCache
ansl - ans list, for calculating the fixpoint
anss - cached answer set, for quickly checking whether an answer term
       is already in the cache</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype AnswerCache [ansl anss _meta]
  Object
  (toString [this]
    (str &quot;&lt;answer-cache:&quot; (pr-str ansl) &quot;&gt;&quot;))
  IMeta
  (-meta [_] _meta)
  IWithMeta
  (-with-meta [_ new-meta]
    (AnswerCache. ansl anss new-meta))
  ILookup
  (-lookup [this k]
    (-lookup this k nil))
  (-lookup [this k not-found]
    (case k
      :ansl ansl
      :anss anss
      not-found))
  proto/IAnswerCache
  (-add [this x]
    (AnswerCache. (conj ansl x) (conj anss x) _meta))
  (-cached? [_ x]
    (let [anss anss]
      (contains? anss x)))
  IPrintWithWriter
  (-pr-writer [x writer opts]
    (-write writer (str x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn answer-cache []
  (AnswerCache. '() #{} nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SuspendedStream [cache ansv* f]
  proto/ISuspendedStream
  (ready? [this]
    (not (identical? (.-ansl @cache) ansv*))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-suspended-stream [cache ansv* f]
  (SuspendedStream. cache ansv* f))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean suspended-stream? [x]
  (instance? SuspendedStream x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean waiting-stream? [x]
  (vector? x))</pre></td></tr><tr><td class="docs"><p>Take a waiting stream, a success continuation, and a failure continuation.
   If we don't find any ready suspended streams, invoke the failure 
   continuation.
   If we find a ready suspended stream calculate the remainder of the waiting
   stream. If we've reached the fixpoint just call the thunk of the suspended
   stream, otherwise call mplus on the result of the thunk and the remainder
   of the waiting stream. Pass this result to the success contination.</p>
</td><td class="codes"><pre class="brush: clojure">(defn waiting-stream-check
  [w success-cont failure-cont]
  (loop [w w a []]
    (cond
     (nil? w) (failure-cont)
     (ready? (first w))
     (success-cont
      (fn []
        (let [ss (first w)
              f  (.-f ss)
              w  (into a (next w))]
          (if (empty? w)
            (f)
            (proto/mplus (f) (fn [] w))))))
     :else (recur (next w) (conj a (first w))))))</pre></td></tr><tr><td class="docs"><p><hr />
Extend Substitutions to support tabling</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>CONSIDER: subunify, reify-term-tabled, extending all the necessary types to
them</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type Substitutions
  proto/ITabled

  ;; returns a substitution that maps fresh vars to
  ;; new ones. similar to Prolog's copy_term/2. this is to avoid
  ;; prematurely grounding vars.
  (-reify-tabled [this v]
    (let [v (walk this v)]
      (cond
       (lvar? v) (ext-no-check this v (lvar (count (.-s this))))
       (coll? v) (-reify-tabled
                  (-reify-tabled this (first v))
                  (next v))
       :else this)))

  ;; returns the term v with all fresh vars replaced with copies.
  ;; this is to avoid prematurely grounding vars.
  (reify-tabled [this v]
    (let [v (walk* this v)]
      (walk* (-reify-tabled empty-s v) v)))

  ;; argv are the actual parameters passed to a goal. cache
  ;; is the cache from the table for reified argv. on initial
  ;; call start and end are nil - so internally they will be
  ;; initialized to the contents of the cache &amp; 0 respectively
  (reuse [this argv cache start end]
    (let [start (or start (.-ansl @cache))
          end   (or end 0)]
      (letfn [(reuse-loop [ansv*]
                (if (= (count ansv*) end)
                  ;; we've run out of answers terms to reuse in the cache
                  [(make-suspended-stream cache start
                                          (fn [] (reuse this argv cache
                                                        (.-ansl @cache)
                                                        (count start))))]
                  ;; we have answer terms to reuse in the cache
                  (let [ans (first ansv*)]
                    ;; FIXME: sets are unordered! - David
                    (Choice. (subunify this argv (reify-tabled this ans))
                             (fn [] (reuse-loop (rest ansv*)))))))]
        (reuse-loop start))))

  ;; unify an argument with an answer from a cache
  (subunify [this arg ans]
    (let [arg (walk this arg)]
      (cond
       (= arg ans) this
       (lvar? arg) (ext-no-check this arg ans)
       (coll? arg) (subunify
                    (subunify this (next arg) (next ans))
                    (first arg) (first ans))
       :else this))))</pre></td></tr><tr><td class="docs"><p><hr />
Waiting Stream</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type PersistentVector
  proto/IBind
  (bind [this g]
    (waiting-stream-check
     this
     ;; success continuation
     (fn [f] (proto/bind f g))
     ;; failure continuation
     (fn []
       (into []
             (map (fn [ss]
                    (make-suspended-stream (.-cache ss) (.-ansv* ss)
                                           (fn [] (proto/bind ((.-f ss)) g))))
                  this)))))

  proto/IMPlus
  (mplus [this f]
    (waiting-stream-check this
                          ;; success continuation
                          (fn [fp] (proto/mplus fp f))
                          ;; failure continuation
                          (fn []
                            (let [a-inf (f)]
                              (if (waiting-stream? a-inf)
                                (into a-inf this)
                                (proto/mplus a-inf (fn [] this)))))))

  proto/ITake
  (take* [this]
    (waiting-stream-check this (fn [f] (take* f)) (fn [] ()))))</pre></td></tr><tr><td class="docs"><p>Take the argument to the goal and check that we don't
   have an alpha equivalent cached answer term in the cache.
   If it doesn't already exist in the cache add the new
   answer term.</p>
</td><td class="codes"><pre class="brush: clojure">(defn master
  [argv cache]
  (fn [a]
    (let [rargv (-reify a argv)]
      (when-not (-cached? @cache rargv)
        (swap! cache
               (fn [cache]
                 (if (-cached? cache rargv)
                   cache
                   (-add cache (reify-tabled a argv)))))
        a))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
cKanren</p>

<p>See - Claire Alvis, Dan Friedman, Will Byrd, et al
"cKanren - miniKanren with Constraints"
http://www.schemeworkshop.org/2011/papers/Alvis2011.pdf
http://github.com/calvis/cKanren</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn addcg [c]
  (fn [a]
    (let [a (reduce (fn [a x]
                      (ext-no-check a x (subst-val ::unbound)))
                    a (unbound-rands a c))]
      (assoc a :cs (proto/addc (.-cs a) a c)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn updatecg [c]
  (fn [a]
    (assoc a :cs (proto/updatec (.-cs a) a c))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn remcg [c]
  (fn [a]
    (assoc a :cs (proto/remc (.-cs a) a c))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn runcg [c]
  (fn [a]
    (assoc a :cs (proto/runc (.-cs a) c true))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stopcg [c]
  (fn [a]
    (assoc a :cs (proto/runc (.-cs a) c false))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean ientailed? [c]
  (satisfies? proto/IEntailed c))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean entailed? [c c' a]
  (let [id (id c)]
    (and (or ((-&gt; a :cs :cm) id)
             (nil? id))
         (proto/-entailed? c'))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn run-constraint [c]
  (fn [a]
    (let [c' (proto/-step c a)]
      (if (or (not (ientailed? c'))
              (not (entailed? c c' a)))
        (if (proto/-runnable? c')
          ((composeg* (runcg c) c' (stopcg c)) a)
          a)
        ((remcg c) a)))))</pre></td></tr><tr><td class="docs"><p>TODO NOW: try an implementation that allows constraints
to run roughly in the order they normally would. reverse
xcs in run-constraints, (into cq (reverse xcs)), cq should
be persistent list.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TRIED: but causes overflow errors for crypt1, and if we switch to BigInt
for crypt1 out of memory errors, needs more investigation</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A goal to run the constraints in cq until it is empty. Of
   course running a constraint may grow cq so this function
   finds the fixpoint.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fix-constraints
  [a]
  (loop [a a]
    (when a
      (let [cq (.-cq a)]
        (if (zero? (count cq))
          (assoc a :cq nil)
          (let [c (first cq)]
            (recur
             ((run-constraint c)
              (-&gt; a
                  (assoc :cq (subvec (.-cq a) 1))
                  (assoc :cqs (disj (.-cqs a) (id c))))))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn run-constraints [xcs]
  (fn [a]
    (let [cq (.-cq a)
          a  (reduce (fn [a c]
                       (proto/queue a c))
                     (assoc a :cq (or cq [])) xcs)]
      (if cq
        a
        (fix-constraints a)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn run-constraints* [xs cs ws]
  (if (or (zero? (count cs))
          (nil? (seq xs)))
    s#
    (fn [a]
      (let [xcs (proto/constraints-for cs a (first xs) ws)]
        (if (seq xcs)
          ((composeg*
            (run-constraints xcs)
            (run-constraints* (next xs) cs ws)) a)
          ((run-constraints* (next xs) cs ws) a))))))</pre></td></tr><tr><td class="docs"><p>TODO: we've hard coded finite domains here</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn verify-all-bound [a constrained]
  (letfn [(verify-all-bound* [a constrained]
            (when constrained
              (let [x (first constrained)]
                (if (and (lvar? x)
                         (and (lvar? (walk a x))
                              (nil? (get-dom a x ::fd))))
                  (throw (ex-info
                          (str &quot;Constrained variable &quot; x &quot; without domain&quot;)
                          {}))
                  (recur a (next constrained))))))]
    (verify-all-bound* a (seq constrained))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn enforceable-constrained [a]
  (let [cs (.-cs a)
        km (.-km cs)
        cm (.-cm cs)
        vs (keys km)]
    (filter (fn [v]
              (some (fn [cid]
                      (when-let [c (get cm cid)]
                        (enforceable? c)))
                    (get km v)))
            vs)))</pre></td></tr><tr><td class="docs"><p>TODO: we've hard coded force-ans here</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare force-ans)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn enforce-constraints [x]
  (all
   (force-ans x)
   (fn [a]
     (let [constrained (enforceable-constrained a)]
       (verify-all-bound a constrained)
       ((onceo (force-ans constrained)) a)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reify-constraints [v r a]
  (let [cs  (.-cs  a)
        rcs (-&gt;&gt; (vals (.-cm cs))
                 (filter reifiable?)
                 (map #(proto/-reifyc % v r a))
                 (filter #(not (nil? %)))
                 (into #{}))]
    (if (empty? rcs)
      (choice v empty-f)
      (choice `(~v :- ~@rcs) empty-f))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reifyg [x]
  (all
   (enforce-constraints x)
   (fn [a]
     (let [v (walk* a x)
           r (-reify* (with-meta empty-s (meta a)) v)]
       (if (zero? (count r))
         (choice v empty-f)
         (let [v (walk* r v)]
           (reify-constraints v r a)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn cgoal [c]
  (reify
    IFn
    (-invoke [_ a]
      (let [c' (proto/-step c a)]
        (if (proto/-runnable? c')
          (when-let [a (c' a)]
            (let [c' (proto/-step c a)]
              (if (and (ientailed? c')
                       (not (entailed? c c' a)))
                ((addcg c) a)
                a)))
          ((addcg c) a))))
    proto/IUnwrapConstraint
    (-unwrap [_] c)))</pre></td></tr><tr><td class="docs"><p>TODO: this stuff needs to be moved into fd - David</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-dom-fd
  [a x]
  (if (lvar? x)
    (get-dom a x ::fd)
    x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sort-by-member-count [a]
  (fn [x y]
    (let-dom a [x dx y dy]
             (&lt; (-member-count dx) (-member-count dy)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sort-by-strategy [v x a]
  (case (-&gt; x meta ::strategy)
    ::ff (seq (sort (sort-by-member-count a) v))
    v))</pre></td></tr><tr><td class="docs"><p>TODO: handle all Clojure tree types</p>
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IForceAnswerTerm
  nil
  (-force-ans [v x] s#)

  default
  (-force-ans [v x]
    (cond (sequential? v)
          (letfn [(loop [ys]
                    (if ys
                      (all
                       (force-ans (first ys))
                       (fn [a]
                         (if-let [ys (sort-by-strategy (next ys) x a)]
                           ((loop ys) a)
                           a)))
                      s#))]
            (loop (seq v)))
          (map? v)
          (letfn [(loop [ys]
                    (if ys
                      (all
                       (force-ans (val (first ys)))
                       (loop (next ys)))
                      s#))]
            (loop (seq v)))
          :else (if (lvar? x)
                  (ext-run-csg x v)
                  s#)))
  LCons
  (-force-ans [v x]
    (letfn [(loop [ys]
              (all
               (force-ans (lfirst ys))
               (if (lcons? (lnext ys))
                 (loop (lnext ys))
                 s#)))]
      (loop v))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn force-ans [x]
  (fn [a]
    ((let [v (walk a x)]
       (if (lvar? v)
         (proto/-force-ans (get-dom-fd a x) v)
         (let [x (proto/root-var a x)]
           (if (sequential? v)
             (proto/-force-ans (sort-by-strategy v x a) x)
             (proto/-force-ans v x))))) a)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn distribute [v* strategy]
  (fn [a]
    (add-attr a v* ::strategy ::ff)))</pre></td></tr><tr><td class="docs"><p>===========================================================================
CLP(Tree)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn disunify
  ([s u v] (disunify s u v {:prefixc {}}))
  ([s u v cs]
     (if (identical? u v)
       cs
       (let [u (walk s u)
             v (walk s v)]
         (if (identical? u v)
           cs
           (if (and (not (lvar? u)) (lvar? v))
             (proto/-disunify-terms v u s cs)
             (proto/-disunify-terms u v s cs)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IDisunifyTerms
  nil
  (-disunify-terms [u v s cs]
    (if-not (nil? v) nil cs))

  LVar
  (-disunify-terms [u v s {pc :prefixc :as cs}]
    (assoc cs :prefixc (assoc pc u v)))

  default
  (-disunify-terms [u v s cs]
    (cond (sequential? u)
          (if (sequential? v)
            (loop [u (seq u) v (seq v) cs cs]
              (if u
                (if v
                  (let [uv (first u)
                        vv (first v)
                        cs (disunify s uv vv cs)]
                    (if cs
                      (recur (next u) (next v) cs)
                      nil))
                  nil)
                (if (nil? v)
                  cs
                  nil)))
            nil)
          (map? u)
          (if (and (map? v) (= (count u) (count v)))
            (loop [ks (seq (keys u)) cs cs]
              (if ks
                (let [kf (first ks)
                      vf (get v kf ::not-found)]
                  (when-not (= vf ::not-found)
                    (if-let [cs (disunify s (get u kf) vf cs)]
                      (recur (next ks) cs)
                      nil)))
                cs))
            nil)
          :else (if-not (= u v) nil cs))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn recover-vars-from-term [x]
  (let [r (atom #{})]
    (proto/walk-term
     x
     (fn [x]
       (if (lvar? x)
         (do (swap! r conj x) x)
         x)))
    @r))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn recover-vars [p]
  (loop [p (seq p) r #{}]
    (if p
      (let [[u v] (first p)]
        (recur (next p)
               (set/union r (recover-vars-from-term u)
                          (recover-vars-from-term v))))
      r)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare normalize-store ground-term?)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn !=c [p]
  (reify
    proto/ITreeConstraint
    proto/IConstraintStep
    (-step [this s]
      (reify
        IFn
        (-invoke [_ s]
          (let [p (loop [sp (seq p) p p]                    
                    (if sp
                      (let [[x v] (first sp)
                            xv (walk* s x)
                            vv (walk* s v)]
                        (cond
                         (= xv vv) (recur (next sp) (dissoc p x))
                         (nil? (unify s xv vv)) nil
                         :else (recur (next sp) (assoc (dissoc p x) xv vv))))
                      p))]
            (if p
              (when-not (empty? p)                
                ((composeg*
                  (remcg this)
                  (cgoal (!=c p))) s))
              ((remcg this) s))))
        proto/IRunnable
        (-runnable? [_]
          (some #(not= (walk s %) %) (recover-vars p)))
        proto/IEntailed
        (-entailed? [_]
          (empty? p))))
    proto/IPrefix
    (-prefix [_] p)
    proto/IWithPrefix
    (-with-prefix [_ p] (!=c p))
    proto/IReifiableConstraint
    (-reifyc [this v r a]
      (let [p* (-reify a (map (fn [[lhs rhs]] `(~lhs ~rhs)) p) r)]
        (if (empty? p*)
          '()
          `(~'!= ~@p*))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic/!=)
    (-rands [_] (seq (recover-vars p)))
    proto/IConstraintWatchedStores
    (-watched-stores [this] #{::subst})))</pre></td></tr><tr><td class="docs"><p>Disequality constraint. Ensures that u and v will never
   unify. u and v can be complex terms.</p>
</td><td class="codes"><pre class="brush: clojure">(defn !=
  [u v]
  (fn [a]
    (let [cs (disunify a u v)]
      (if-not (nil? cs)
        (let [p (:prefixc cs)]
          (when-not (empty? p)
            (if (some (fn [[u v]] (nil? (unify a u v))) p)
              a
              ((cgoal (!=c p)) a))))
        a))))</pre></td></tr><tr><td class="docs"><p>A relation which guarantees no element of l will unify
   with another element of l.</p>
</td><td class="codes"><pre class="brush: clojure">(defne distincto
  [l]
  ([()])
  ([[h]])
  ([[h0 h1 . t]]
     (!= h0 h1)
     (distincto (lcons h0 t))
     (distincto (lcons h1 t))))</pre></td></tr><tr><td class="docs"><p>A relation between l and o where is removed from
   l exactly one time.</p>
</td><td class="codes"><pre class="brush: clojure">(defne rembero
  [x l o]
  ([_ [x . xs] xs])
  ([_ [y . ys] [y . zs]]
     (!= y x)
     (rembero x ys zs)))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Partial Maps</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare featurec partial-map)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unify-with-pmap* [u v s]
  (loop [ks (keys u) s s]
    (if (seq ks)
      (let [kf (first ks)
            vf (get v kf ::not-found)]
        (if (= vf ::not-found)
          nil
          (let [uf (get u kf)]
            (if (lvar? vf)
              (recur (next ks) ((featurec vf uf) s))
              (if (map? uf)
                (if-let [s (unify s (partial-map uf) vf)]
                  (recur (next ks) s))
                (if-let [s (unify s uf vf)]
                  (recur (next ks) s)
                  nil))))))
      s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare partial-map?)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord PMap []
  proto/INonStorable
  proto/IUnifyTerms
  (unify-terms [u v s]
    (if (map? v)
      (unify-with-pmap* u v s)
      nil))
  proto/IUnifyWithRecord
  (unify-with-record [u v s]
    (if (map? v)
      (unify-with-pmap* u v s)
      nil))
  proto/IUninitialized
  (-uninitialized [_] (PMap.)))</pre></td></tr><tr><td class="docs"><p>Given map m, returns partial map that unifies with maps even if it
   doesn't share all of the keys of that map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn partial-map
  [m]
  (map-&gt;PMap m))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean partial-map? [x]
  (instance? PMap x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IFeature
  default
  (-feature [x]
    (cond (map? x) (partial-map x)
          :else nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -featurec
  [x fs]
  (reify
    proto/IConstraintStep
    (-step [this s]
      (reify
        IFn
        (-invoke [_ s]
          ((composeg
            (== fs x)
            (remcg this)) s))
        proto/IRunnable
        (-runnable? [_]
          (not (lvar? (walk s x))))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic/featurec)
    (-rands [_] [x])
    proto/IReifiableConstraint
    (-reifyc [_ v r a]
      (let [fs (into {} fs)
            r  (-reify* r (walk* a fs))]
        `(featurec ~(walk* r x) ~(walk* r fs))))
    proto/IConstraintWatchedStores
    (-watched-stores [this] #{::subst})))</pre></td></tr><tr><td class="docs"><p>Ensure that a map contains at least the key-value pairs
  in the map fs. fs must be partially instantiated - that is,
  it may contain values which are logic variables to support
  feature extraction.</p>
</td><td class="codes"><pre class="brush: clojure">(defn featurec
  [x fs]
  (cgoal (-featurec x (partial-map fs))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
defnc</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean ground-term? [x s]
  (letfn [(-ground-term? [x s]
            (let [x (walk s x)]
              (if (lvar? x)
                (throw fk)
                (proto/walk-term x
                           (fn [x]
                             (let [x (walk s x)]
                               (cond
                                (lvar? x) (throw fk)
                                (tree-term? x) (-ground-term? x s)
                                :else x)))))))]
    (try
      (-ground-term? x s)
      true
      (catch js/Error e
        false))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Predicate Constraint</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -predc
  ([x p] (-predc x p p))
  ([x p pform]
     (reify
       proto/IConstraintStep
       (-step [this s]
         (reify
           IFn
           (-invoke [_ s]
             (let [x (walk s x)]
               (when (p x)
                 ((remcg this) s))))
           proto/IRunnable
           (-runnable? [_]
             (not (lvar? (walk s x))))))
       proto/IConstraintOp
       (-rator [_] (if (seq? pform)
                     `(predc ~pform)
                     `cljs.core.logic/predc))
       (-rands [_] [x])
       proto/IReifiableConstraint
       (-reifyc [c v r s]
         (if (and (not= p pform) (fn? pform))
           (pform c v r s)
           pform))
       proto/IConstraintWatchedStores
       (-watched-stores [this] #{::subst}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn predc
  ([x p] (predc x p p))
  ([x p pform]
     (cgoal (-predc x p pform))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Negation as failure</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn tramp [f]
  (loop [f f]
    (if (fn? f)
      (recur (f))
      f)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -nafc
  ([c args]
     (reify
       proto/IConstraintStep
       (-step [this s]
         (reify
           IFn
           (-invoke [_ s]
             (when-not (tramp ((apply c args) s))
               ((remcg this) s)))
           proto/IRunnable
           (-runnable? [_]
             (every? #(ground-term? % s) args))))
       proto/IConstraintOp
       (-rator [_] `cljs.core.logic/nafc)
       (-rands [_] (vec (concat [c] args)))
       proto/IReifiableConstraint
       (-reifyc [_ v r s]
         `(nafc ~c ~@(-reify s args r)))
       proto/IConstraintWatchedStores
       (-watched-stores [this] #{::subst}))))</pre></td></tr><tr><td class="docs"><p>EXPERIMENTAL: negation as failure constraint. All arguments to the goal c
   must be ground. If some argument is not ground the execution of this 
   constraint will be delayed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nafc
  [c &amp; args]
  (cgoal (-nafc c args)))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Deep Constraint</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare treec)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IConstrainTree
  LCons
  (-constrain-tree [t fc s]
    (loop [t t s s]
      (if (lvar? t)
        (fc t s)
        (when-let [s (fc (lfirst t) s)]
          (recur (lnext t) s)))))

  default
  (-constrain-tree [t fc s]
    (cond (sequential? t)
          (loop [t (seq t) s s]
            (if t
              (when-let [s (fc (first t) s)]
                (recur (next t) s))
              s))
          (map? t)
          (loop [t (seq t) s s]
            (if t
              (let [[_ v] (first t)
                    s (fc v s)]
                (when s
                  (recur (next t) s)))
              s))
          :else nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn constrain-tree [t fc]
  (fn [a]
    (proto/-constrain-tree t fc a)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -fixc
  ([x f reifier] (-fixc x f nil reifier))
  ([x f runnable reifier]
     (reify
       proto/IConstraintStep
       (-step [this s]
         (let [xv (walk s x)]
           (reify
             IFn
             (-invoke [_ s]
               ((composeg (f xv s reifier) (remcg this)) s))
             proto/IRunnable
             (-runnable? [_]
               (if (fn? runnable)
                 (runnable x s)
                 (not (lvar? xv)))))))
       proto/IConstraintOp
       (-rator [_] `cljs.core.logic/fixc)
       (-rands [_] (if (vector? x) x [x]))
       proto/IReifiableConstraint
       (-reifyc [c v r s]
         (if (fn? reifier)
           (reifier c x v r s)
           (let [x (walk* r x)]
             `(fixc ~x ~reifier))))
       proto/IConstraintWatchedStores
       (-watched-stores [this] #{::subst}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fixc
  ([x f reifier] (fixc x f nil reifier))
  ([x f runnable reifier]
     (cgoal (-fixc x f runnable reifier))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn treec [x fc reifier]
  (fixc x
        (fn loop [t a reifier]
          (if (tree-term? t)
            (composeg*
             (fc t)
             (constrain-tree t (fn [t a] ((fixc t loop reifier) a))))
            (fc t)))
        reifier))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn seqc [v]
  (fixc v
        (fn [t _ _]
          (cond
           (sequential? t) succeed
           (lcons? t) (seqc (lnext t))
           :else fail))
        (fn [_ v _ r a]
          `(seqc ~(-reify a v r)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (run* [answer]
    (== answer 5))
  (run* [v1 v2]
    (== {:a v1 :b 2}
        {:a 1 :b v2}))
  (run* [x y]
    (== x y))
  (run* [q]
    (== q 1)
    (== q 2))
  (run* [george]
    (conde
     [(== george :born)]
     [(== george :unborn)]))
  `(+ 1 ~(do 2))
  (run* [q]
    (== q [1 2]))

  (run* [q]
    (fresh [x y]
      (== q [x y])
      (!= y &quot;Java&quot;)))

  (run* [q] (!= q &quot;Java&quot;))

  (run* [q]
    (fresh [x y]
      (== [:pizza &quot;Java&quot;] [x y])
      (== q [x y])
      (!= y &quot;Java&quot;)))

  (run* [q]
    (fresh [x y]
      (== [:pizza &quot;Scala&quot;] [x y])
      (== q [x y])
      (!= y &quot;Java&quot;)))
  
  (run* [q]
    (fresh [n]
      (!= 0 n)
      (== q n)))
  )</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.bench" name="cljs.core.logic.bench"><h1 class="project-name">cljs.core.logic.bench</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.bench
  (:refer-clojure :exclude [==])
  (:require [cljs.core.logic.protocols :as proto]
            [cljs.core.logic :as l :refer [appendo != s# u# lcons pair]]
            [cljs.core.logic.fd :as fd]
            [cljs.core.logic.pldb :as pldb :refer [db-fact]]
            [cljs.core.logic.nominal :as nom]
            [clojure.core.reducers :as r]
            [clojure.set :as set]
            [cljs.reader :as reader]
            [goog.functions :as gfns])
  (:require-macros [cljs.core.logic.macros
                    :refer [umi uai llist composeg* bind* mplus* -inc
                            conde fresh -run run run* run-db run-db* run-nc
                            run-nc* all is pred project trace-lvars trace-s
                            log ifa* ifu* conda condu lvaro nonlvaro fnm
                            defnm fne defne matche fna fnu defna defnu matcha
                            matchu tabled let-dom fnc defnc in db-rel
                            with-db]]
                   [cljs.core.logic.bench :as bench :refer [==]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bit-nando
  [x y r]
  (conde [(== 0 x) (== 0 y) (== 1 r)]
         [(== 0 x) (== 1 y) (== 1 r)]
         [(== 1 x) (== 0 y) (== 1 r)]
         [(== 1 x) (== 1 y) (== 0 r)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bit-xoro
  [x y r]
  (fresh [s t u]
    (bit-nando x y s)
    (bit-nando x s t)
    (bit-nando s y u)
    (bit-nando t u r)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bit-noto
  [x r]
  (bit-nando x x r))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bit-ando
  [x y r]
  (fresh [s]
    (bit-nando x y s)
    (bit-noto s r)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn half-addero
  [x y r c]
  (all
   (bit-xoro x y r)
   (bit-ando x y c)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn full-addero
  [b x y r c]
  (fresh [w xy wz]
    (half-addero x y w xy)
    (half-addero w b r wz)
    (bit-xoro xy wz c)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn build-num
  [n]
  (loop [n n num []]
    (cond (odd? n)
          (recur (quot (dec n) 2) (conj num 1))
          (and (not (zero? n)) (even? n))
          (recur (quot n 2) (conj num 0))
          (zero? n) num)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn poso
  [n]
  (fresh [a d]
    (== (lcons a d) n)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def not-found (js-obj))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn assq
  [k ^not-native xs]
  (loop [^not-native xs (-seq xs)]
    (if (nil? xs)
      not-found
      (let [x (-first xs)
            lhs (.-lhs x)]
        (if (identical? k lhs)
          (.-rhs x)
          (recur (-next xs)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (run* [q]
    (== q true))

  (dotimes [_ 10]
    (time
     (dotimes [_ 10000]
       (doall
        (run* [q]
          (== q true)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (time (doall (run 100 [q]
                 (fresh [x y]
                   (appendo x y q)))))

  ;; 453ms
  (dotimes [_ 5]
    (time
     (dotimes [_ 1]
       (doall
        (run 700 [q]
          (fresh [x y]
            (appendo x y q))))))))</pre></td></tr><tr><td class="docs"><p> =============================================================================
 nrev
 =============================================================================</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne nrevo [l o]
  ([() ()])
  ([[a . d] _]
     (fresh [r]
       (nrevo d r)
       (appendo r [a] o))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  ;; we can run backwards, unlike Prolog
  (run 1 [q] (nrevo q (range 30)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; SWI-Prolog 0.06-0.08s
  ;; ~3.7s
  (let [data (into [] (range 30))]
    (dotimes [_ 5]
      (time
       (dotimes [_ 1e3]
         (doall (run-nc 1 [q] (nrevo data q)))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; the LIPS are ridiculously high for SWI-Prolog
  ;; clearly nrev is a case that SWI-Prolog can optimize away
  )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 zebra
 =============================================================================</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne righto [x y l]
  ([_ _ [x y . r]])
  ([_ _ [_ . r]] (righto x y r)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn nexto [x y l]
  (conde
   [(righto x y l)]
   [(righto y x l)]))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn zebrao [hs]
  (all
   (== [(lvar) (lvar) [(lvar) (lvar) 'milk (lvar) (lvar)] (lvar) (lvar)] hs)
   (firsto hs ['norwegian (lvar) (lvar) (lvar) (lvar)])
   (nexto ['norwegian (lvar) (lvar) (lvar) (lvar)] [(lvar) (lvar) (lvar) (lvar) 'blue] hs)
   (righto [(lvar) (lvar) (lvar) (lvar) 'ivory] [(lvar) (lvar) (lvar) (lvar) 'green] hs)
   (membero ['englishman (lvar) (lvar) (lvar) 'red] hs)
   (membero [(lvar) 'kools (lvar) (lvar) 'yellow] hs)
   (membero ['spaniard (lvar) (lvar) 'dog (lvar)] hs)
   (membero [(lvar) (lvar) 'coffee (lvar) 'green] hs)
   (membero ['ukrainian (lvar) 'tea (lvar) (lvar)] hs)
   (membero [(lvar) 'lucky-strikes 'oj (lvar) (lvar)] hs)
   (membero ['japanese 'parliaments (lvar) (lvar) (lvar)] hs)
   (membero [(lvar) 'oldgolds (lvar) 'snails (lvar)] hs)
   (nexto [(lvar) (lvar) (lvar) 'horse (lvar)] [(lvar) 'kools (lvar) (lvar) (lvar)] hs)
   (nexto [(lvar) (lvar) (lvar) 'fox (lvar)] [(lvar) 'chesterfields (lvar) (lvar) (lvar)] hs)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (run 1 [q] (zebrao q))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; SWI-Prolog 6-8.5s
  ;; now 2.5-2.6s, old days &lt;2.4s
  (dotimes [_ 5]
    (time
     (dotimes [_ 1e3]
       (doall (run-nc 1 [q] (zebrao q))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; now ~4s, in old days closer to ~3.7s
  (dotimes [_ 5]
    (time
     (dotimes [_ 1e3]
       (doall (run 1 [q] (zebrao q)))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 cliques</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(pldb/db-rel connected ^:index x ^:index y)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def connected-db
  (pldb/db
   [connected [[1 2] [1 5]]]
   [connected [[2 1] [2 3] [2 5]]]
   [connected [[3 2] [3 4]]]
   [connected [[4 3] [4 5] [4 6]]]
   [connected [[5 1] [5 2] [5 4]]]
   [connected [[6 4]]]))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne connected-to-allo
  "Ensure that vertex v is connected to all vertices
   vs."
  [v vs]
  ([_ ()])
  ([_ [vh . vr]]
     (connected v vh)
     (connected-to-allo v vr)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne all-connected-to-allo
  "Collect all cliques in l. l must be bounded to ensure
   termination."
  [l]
  ([()])
  ([[h . t]]
     (connected-to-allo h t)
     (all-connected-to-allo t)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (run-nc* [q]
           (fresh [a b d]
             (== q (llist a b d))
             (fd/bounded-listo q 6)
             (all-connected-to-allo q)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; 350-400ms
  (dotimes [_ 5]
    (time
     (dotimes [_ 100]
       (doall
        (pldb/with-db connected-db
          (run-nc 20 [q]
                  (fresh [a b d]
                    (== q (llist a b d))
                    (fd/bounded-listo q 6)
                    (all-connected-to-allo q)))))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 nqueens</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> Bratko 3d pg 103</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (declare noattacko)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (defne nqueenso [l]
    ([()])
    ([[[x y] . others]]
       (nqueenso others)
       (membero y [1 2 3 4 5 6 7 8])
       (noattacko [x y] others)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (defne noattacko [q others]
    ([_ ()])
    ([[x y] [[x1 y1] . r]]
       (!= y y1)
       (project [y y1 x x1]
         (!= (- y1 y) (- x1 x))
         (!= (- y1 y) (- x x1)))
       (noattacko [x y] r)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (defn solve-nqueens []
    (run-nc* [q]
             (fresh [y1 y2 y3 y4 y5 y6 y7 y8]
               (== q [[1 y1] [2 y2] [3 y3] [4 y4] [5 y5] [6 y6] [7 y7] [8 y8]])
               (nqueenso q)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (take 1 (solve-nqueens))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; 92 solutions
  (count (solve-nqueens))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; &lt; 3s for 100x
  ;; about 18X slower that SWI
  (dotimes [_ 5]
    (time
     (dotimes [_ 1]
       (doall (take 1 (solve-nqueens))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~550ms
  (dotimes [_ 10]
    (time
     (dotimes [_ 1]
       (doall (solve-nqueens)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~610ms
  (dotimes [_ 10]
    (time
     (dotimes [_ 1]
       (doall (solve-nqueens)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; nqueens benefits from constraints
  )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 nqueensfd</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> based on Bratko 3d pg 344, constraint version</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  ;; direct translation does not work
  ;; because of the subtraction constraints
  ;; also, some domain inference would be nice</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (defne noattackfd [y ys d]
    ([_ () _])
    ([y1 [y2 . yr] d]
       (fresh [x nd]
         (fd/in x nd (fd/interval 1 8))
         (fd/!= d x)
         (conde
          [(fd/&lt; y1 y2) (fd/+ y1 x y2)]
          [(fd/&lt; y2 y1) (fd/+ y2 x y1)])
         (fd/+ d 1 nd)
         (noattackfd y1 yr nd)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code>(defne safefd [l]
  ([()])
  ([[y . ys]]
     (noattackfd y ys 1)
     (safefd ys))))
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (defn nqueensfd []
    (run* [q]
      (fresh [a b c d e f g h]
        (fd/in a b c d e f g h (fd/interval 1 8))
        (== q [a b c d e f g h])
        (fd/distinct q)
        (safefd q))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (nqueensfd)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (run* [q]
    (fresh [a b]
      (fd/in a b (fd/interval 1 8))
      (== q [a b])
      (safefd q))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 send more money</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne takeouto [x l y]
  ([_ [x . y] _])
  ([_ [h . t] [h . r]] (takeouto x t r)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn digito [x l y]
  (takeouto x l y))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn first-digito [x l y]
  (all
   (digito x l y)
   (a/> x 0)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne do-send-moolao [q l ll]
  ([[send more money] _ _]
     (fresh [s e n d m o r y
             l1 l2 l3 l4 l5 l6 l7 l8 l9]
       (first-digito s l l1)
       (first-digito m l1 l2)
       (digito e l2 l3)
       (digito n l3 l4)
       (digito d l4 l5)
       (digito o l5 l6)
       (digito r l6 l7)
       (digito y l7 l8)
       (project [s e n d m o r y]
         (== send (+ (* s 1000) (* e 100) (* n 10) d))
         (== more (+ (* m 1000) (* o 100) (* r 10) e))
         (== money (+ (* m 10000) (* o 1000) (* n 100) (* e 10) y))
         (project [send more]
           (== money (+ send more)))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn send-money-quicklyo [send more money]
  (fresh [l]
    (do-send-moolao [send more money] (range 10) l)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  ;; ~16-17s, w/o occurs-check
  ;; SWI-Prolog takes 4s, so 3.8X faster
  ;; again I suspect the overhead here is from
  ;; interleaving, need to figure
  (time
   (run-nc 1 [q]
           (fresh [send more money]
             (send-money-quicklyo send more money)
             (== [send more money] q)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 Cryptarithmetic Puzzle</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn cryptarithfd-1 []
  (run-nc* [s e n d m o r y :as q]
           (fd/in s e n d m o r y (fd/interval 0 9))
           (fd/distinct q)
           (distribute q ::l/ff)
           (fd/!= m 0) (fd/!= s 0)
           (fd/eq
            (=             (+ (* 1000 s) (* 100 e) (* 10 n) d
                              (* 1000 m) (* 100 o) (* 10 r) e)
                           (+ (* 10000 m) (* 1000 o) (* 100 n) (* 10 e) y)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> Bratko 3rd ed pg 343</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn cryptarithfd-2 []
  (run-nc* [d o n a l g e r b t :as q]
           (distribute q ::l/ff)
           (fd/in d o n a l g e r b t (fd/interval 0 9))
           (fd/distinct q)
           (fd/eq
            (= (+ (* 100000 d) (* 10000 o) (* 1000 n) (* 100 a) (* 10 l) d
                  (* 100000 g) (* 10000 e) (* 1000 r) (* 100 a) (* 10 l) d)
               (+ (* 100000 r) (* 10000 o) (* 1000 b) (* 100 e) (* 10 r) t)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  ;; FIXME: we don't see as much propagation as Oz, why not?</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (cryptarithfd-1)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (time (cryptarithfd-1))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~1050ms, a little bit slower w/ distribute step
  (dotimes [_ 5]
    (time
     (dotimes [_ 100]
       (doall (cryptarithfd-1)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; 3X slower still
  (dotimes [_ 5]
    (time
     (dotimes [_ 10]
       (doall (cryptarithfd-1)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; WORKS: takes a long time ([5 2 6 4 8 1 9 7 3 0])
  ;; ~1.3s now
  (dotimes [_ 5]
    (time (doall (cryptarithfd-2)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 Hanoi</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne moveo [n x y z]
  ([1 _ _ _]
     (trace-lvars "Move top disk from " x)
     (trace-lvars " to " y))
  ([_ _ _ _]
     (pred n #(> % 1))
     (fresh [m _] (is m n dec)
       (moveo m x z y) (moveo 1 x y _) (moveo m z y x))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (run* [q]
    (moveo 3 :left :right :center)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 Quick Sort</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(declare partitiono)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne qsorto [l r r0]
  ([[] _ r])
  ([[x . lr] _ _]
     (fresh [l1 l2 r1]
       (partitiono lr x l1 l2)
       (qsorto l2 r1 r0)
       (qsorto l1 r (lcons x r1)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne partitiono [a b c d]
  ([[x . l] _ [x . l1] _]
     (conda
      ((project [x b]
         (== (&lt;= x b) true))
       (partition l b l1 d))
      (partition l b c d))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 Dinesman Dwelling Problem with CLP(FD)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn not-adjacento [x y]
  (fresh [f]
    (fd/in f (fd/interval 1 5))
    (conde
     [(fd/+ x f y) (fd/&lt; 1 f)]
     [(fd/+ y f x) (fd/&lt; 1 f)])))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn dinesmanfd []
  (run* [baker cooper fletcher miller smith :as vs]
    (fd/distinct vs)
    (everyg #(fd/in % (fd/interval 1 5)) vs)
    (fd/!= baker 5) (fd/!= cooper 1)
    (fd/!= fletcher 5) (fd/!= fletcher 1)
    (fd/&lt; cooper miller)
    (not-adjacento smith fletcher)
    (not-adjacento fletcher cooper)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn sort-dwellers [[fa _] [fb _]]
  (cond (&lt; fa fb) -1 (= fa fb) 0 :else 1))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn ->answer [ns]
  (->> (map vector ns [:baker :cooper :fletcher :miller :smith])
       (sort sort-dwellers)
       (map second)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (time (doall (dinesmanfd)))
  ;; close to 2X faster than Petite Chez
  ;; ~1942ms
  (dotimes [_ 5]
    (time
     (dotimes [_ 1000]
       (doall (dinesmanfd)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (-> (dinesmanfd) first ->answer)  ; (:smith :cooper :baker :fletcher :miller)
  )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 Simple</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn simplefd []
  (run* [x y]
    (fd/in x y (fd/interval 0 9))
    (fd/+ x y 9)
    (fresh [p0 p1]
      (fd/* 2 x p0)
      (fd/* 4 y p1)
      (fd/+ p0 p1 24))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> with fd/eq sugar</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn simple-fd-eq []
  (run* [x y]
    (fd/in x y (fd/interval 0 9))
    (fd/eq
     (= (+ x y) 9)
     (= (+ (* x 2) (* y 4)) 24))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  ;; "Finite Domain Constraint Programming in Oz. A Tutorial." (Schulte &amp; Smolka)
  ;; currently none of the constraints above trigger any refinements!
  (simplefd)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (simple-fd-eq)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; 620ms
  (dotimes [_ 10]
    (time
     (dotimes [_ 1e3]
       (doall (simple-fd-eq)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (run* [q]
    (fresh [a b]
      (fd/* a 3 34)
      (debug-doms))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 Stone Problem</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> w  - is a stone (weight)
 sl - stone (weight) list
 r  - the input range we can construct
 o  - the output range we can construct
 n  - the bound</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defne subchecko [w sl r o n]
  ;; we have no more stones to test in sl to test w with
  ([_ () _ _ _]
     (fresh [hr]
       (fd/in hr (fd/interval 1 n))
       (matche [r o]
               ;; r is not empty, we add w to the output only if
               ;; w is head of r + 1
               ([[hr . _] [w . r]] (fd/+ hr 1 w))
               ;; r is empty, just add the weight
               ;; only works for w == 1
               ([() [w . r]]))))
  ;; we have stones to in sl to test w with
  ([_ [hsl . rsl] _ _ _]
     (fresh [w-hsl w+hsl o0 o1 nw]
       (fd/in hsl w-hsl w+hsl (fd/interval 1 n))
       (fd/+ hsl w-hsl w) (fd/+ hsl w w+hsl)
       ;; attempt to construct values prior w
       (subchecko w-hsl rsl r  o0 n)
       ;; attempt to construct values around w
       (subchecko w     rsl o0 o1 n)
       ;; attempt to construct values after w
       (subchecko w+hsl rsl o1 o  n))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> checks that list of weight can produce the list
 of integers from 1 to 40, in reverse order (40 ... 1)
(defne checko [ws sl r n]
  ;; if ws is empty, the first element of r must be n
  ([() _ [a . _] a])
  ;; otherwise we check the first weight
  ([[w . wr] _ _ _]
     (fresh [nsl nr]
       ;; check the first weight with subchecko
       (subchecko w sl r nr n)
       ;; if it succeeds we add w to the new stone list
       (conso w sl nsl)
       ;; check remaining weights
       (checko wr nsl nr n))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn matches [n]
  (run 1 [a b c d]
    (fd/in a b c d (fd/interval 1 n))
    (fd/distinct [a b c d])
    (== a 1)
    (fd/&lt;= a b) (fd/&lt;= b c) (fd/&lt;= c d)
    (fd/eq (= (+ a b c d) n))
    (checko [a b c d] () () n)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (time (doall (matches 40)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~6.3s
  (dotimes [_ 5]
    (time
     (dotimes [_ 1000]
       (doall (matches 40))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> =============================================================================
 Sudoku</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p><hr />
 small</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn small-sudokufd []
  (run-nc 1 [q]
          (fresh [a1 a2 a3 a4
                  b1 b2 b3 b4
                  c1 c2 c3 c4
                  d1 d2 d3 d4]
            (== q [[a1 a2 a3 a4]
                   [b1 b2 b3 b4]
                   [c1 c2 c3 c4]
                   [d1 d2 d3 d4]])
            (fd/in a1 a2 a3 a4
                   b1 b2 b3 b4
                   c1 c2 c3 c4
                   d1 d2 d3 d4
                   (fd/domain 1 2 3 4))
            (let [row1 [a1 a2 a3 a4]
                  row2 [b1 b2 b3 b4]
                  row3 [c1 c2 c3 c4]
                  row4 [d1 d2 d3 d4]
                  col1 [a1 b1 c1 d1]
                  col2 [a2 b2 c2 d2]
                  col3 [a3 b3 c3 d3]
                  col4 [a4 b4 c4 d4]
                  sq1 [a1 a2 b1 b2]
                  sq2 [a3 a4 b3 b4]
                  sq3 [c1 c2 d1 d2]
                  sq4 [c3 c4 d3 d4]]
              (everyg fd/distinct
                      [row1 row2 row3 row4
                       col1 col2 col3 col4
                       sq1 sq2 sq3 sq4])))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  ;; 1.9s
  (dotimes [_ 10]
    (time
     (dotimes [_ 1e3]
       (doall (small-sudokufd)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (small-sudokufd))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p><hr />
 9x9</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn get-square [rows x y]
  (for [x (range x (+ x 3))
        y (range y (+ y 3))]
    (get-in rows [x y])))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn init [vars hints]
  (if (seq vars)
    (let [hint (first hints)]
      (all
       (if-not (zero? hint)
         (== (first vars) hint)
         succeed)
       (init (next vars) (next hints))))
    succeed))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn ->rows [xs]
  (->> xs (partition 9) (map vec) (into [])))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn ->cols [rows]
  (apply map vector rows))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn ->squares [rows]
  (for [x (range 0 9 3)
        y (range 0 9 3)]
    (get-square rows x y)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn sudokufd [hints]
  (let [vars (repeatedly 81 lvar)
        rows (->rows vars)
        cols (->cols rows)
        sqs  (->squares rows)]
    (run-nc 1 [q]
            (== q vars)
            ;;(distribute q ::l/ff)
            (everyg #(fd/in % (fd/domain 1 2 3 4 5 6 7 8 9)) vars)
            (init vars hints)
            (everyg fd/distinct rows)
            (everyg fd/distinct cols)
            (everyg fd/distinct sqs))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> Helpers</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn verify [vars]
  (let [rows (->rows vars)
        cols (->cols rows)
        sqs  (->squares rows)
        verify-group (fn [group]
                       (every? #(= (->> % (into #{}) count) 9)
                               group))]
    (and (verify-group rows)
         (verify-group cols)
         (verify-group sqs))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn print-solution [vars]
  (doseq [row-group (->> vars
                         (partition 9)
                         (partition 3)
                         (interpose "\n\n"))]
    (if-not (string? row-group)
      (doseq [row (interpose "\n" row-group)]
        (if-not (string? row)
          (doseq [x (->> row
                         (partition 3)
                         (map #(interpose " " %))
                         (interpose "  "))]
            (print (apply str x)))
          (print row)))
      (print row-group)))
  (println) (println))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (def easy0
    [0 0 3  0 2 0  6 0 0
     9 0 0  3 0 5  0 0 1
     0 0 1  8 0 6  4 0 0</p>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 0 0 8  1 0 2  9 0 0
 7 0 0  0 0 0  0 0 8
 0 0 6  7 0 8  2 0 0
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 0 0 2  6 0 9  5 0 0
 8 0 0  2 0 3  0 0 9
 0 0 5  0 1 0  3 0 0])
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (def easy1
    [2 0 0  0 8 0  3 0 0
     0 6 0  0 7 0  0 8 4
     0 3 0  5 0 0  2 0 9</p>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 0 0 0  1 0 5  4 0 8
 0 0 0  0 0 0  0 0 0
 4 0 2  7 0 6  0 0 0
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 3 0 1  0 0 7  0 4 0
 7 2 0  0 4 0  0 6 0
 0 0 4  0 1 0  0 0 3])
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (sudokufd easy0)
  (time (doall (sudokufd easy0)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (sudokufd easy1)
  (time (sudokufd easy1))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (-> (sudokufd easy0) first print-solution)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (-> (sudokufd easy0) first verify)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~900ms w/o distribute
  (dotimes [_ 5]
    (time
     (dotimes [_ 100]
       (doall (sudokufd easy0)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~1000ms w/o distribute
  (dotimes [_ 5]
    (time
     (dotimes [_ 100]
       (doall (sudokufd easy1)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; Hardest Norvig Random
  (def hard0
    [0 0 0  0 0 6  0 0 0
     0 5 9  0 0 0  0 0 8
     2 0 0  0 0 8  0 0 0</p>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 0 4 5  0 0 0  0 0 0
 0 0 3  0 0 0  0 0 0
 0 0 6  0 0 3  0 5 4
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 0 0 0  3 2 5  0 0 6
 0 0 0  0 0 0  0 0 0
 0 0 0  0 0 0  0 0 0])
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~5.2s w/o distribute
  (time (doall (sudokufd hard0)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (-> (sudokufd hard0) first verify)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (dotimes [_ 5]
    (time
     (dotimes [_ 100]
       (doall (sudokufd hard0)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; from GeCode test suite
  (def hard1
    [0 0 0  0 0 3  0 6 0
     0 0 0  0 0 0  0 1 0
     0 9 7  5 0 0  0 8 0</p>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 0 0 0  0 9 0  2 0 0
 0 0 8  0 7 0  4 0 0
 0 0 3  0 6 0  0 0 0
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 0 1 0  0 0 2  8 9 0
 0 4 0  0 0 0  0 0 0
 0 5 0  1 0 0  0 0 0])
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~50ms
  (time (doall (sudokufd hard1)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (-> (sudokufd hard1) first verify)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~2.5 seconds w/o distribute
  ;; &lt; 260ms w/ distribute, nearly 10X faster
  (dotimes [_ 5]
    (time
     (dotimes [_ 10]
       (doall (sudokufd hard1)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; from Wikipedia
  (def hard2
    [1 2 0  4 0 0  3 0 0
     3 0 0  0 1 0  0 5 0
     0 0 6  0 0 0  1 0 0</p>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 7 0 0  0 9 0  0 0 0
 0 4 0  6 0 3  0 0 0
 0 0 3  0 0 2  0 0 0
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 5 0 0  0 8 0  7 0 0
 0 0 7  0 0 0  0 0 5
 0 0 0  0 0 0  0 9 8])
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~.9s w/ distribute
  (time (doall (sudokufd hard2)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (-> (sudokufd hard2) first print-solution)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (dotimes [_ 5]
    (time
     (doall (sudokufd hard2))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (def ciao
    [0 4 3  0 8 0  2 5 0
     6 0 0  0 0 0  0 0 0
     0 0 0  0 0 1  0 9 4</p>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 9 0 0  0 0 4  0 7 0
 0 0 0  6 0 8  0 0 0
 0 1 0  2 0 0  0 0 3
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 8 2 0  5 0 0  0 0 0
 0 0 0  0 0 0  0 0 5
 0 3 4  0 9 0  7 1 0])
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~13ms w/o distribute
  ;; ~18ms w/ distribute
  (dotimes [_ 5]
    (time
     (dotimes [_ 100]
       (doall (sudokufd ciao)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (def jacop
    [0 1 0  4 2 0  0 0 5
     0 0 2  0 7 1  0 3 9
     0 0 0  0 0 0  0 4 0</p>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 2 0 7  1 0 0  0 0 6
 0 0 0  0 4 0  0 0 0
 6 0 0  0 0 7  4 0 3
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code> 0 7 0  0 0 0  0 0 0
 1 2 0  7 3 0  5 0 0
 3 0 0  0 8 2  0 7 0])
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; 400ms
  (dotimes [_ 5]
    (time
     (dotimes [_ 10]
       (doall (sudokufd jacop))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> From "Finite Domain Constraint Programming in Oz. A Tutorial" pg 22</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn safefd []
  (run* [c1 c2 c3 c4 c5 c6 c7 c8 c9 :as vs]
    (everyg #(fd/in % (fd/interval 1 9)) vs)
    (fd/distinct vs)
    (fd/eq
     (= (- c4 c6) c7)
     (= (* c1 c2 c3) (+ c8 c9))
     (&lt; (+ c2 c3 c6) c8)
     (&lt; c9 c8))
    (project [vs]
      (everyg (fn [[v n]] (fd/!= v n))
              (map vector vs (range 1 10))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  (time (safefd))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  (every?
   (fn [[c1 c2 c3 c4 c5 c6 c7 c8 c9]]
     (and
      (not= c1 1) (not= c2 2) (not= c3 3)
      (not= c4 4) (not= c5 5) (not= c6 6)
      (not= c7 7) (not= c8 8) (not= c9 9)
      (= (- c4 c6) c7)
      (= (* c1 c2 c3) (+ c8 c9))
      (&lt; (+ c2 c3 c6) c8)
      (&lt; c9 c8)))
   (safefd))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~2300ms
  (dotimes [_ 5]
    (time
     (dotimes [_ 100]
       (doall (safefd))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> Magic Squares</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn magic-grid [n]
  (repeatedly (* n n) lvar))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn magic-cols [n grid]
  (apply map list (partition n grid)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn magic-diag [n rows]
  (first
   (reduce
    (fn [[r n] xs]
      [(conj r (nth xs n)) (inc n)])
    [[] 0]
    rows)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn magic-sum [ls res]
  (conde
   [(== ls []) (== res 0)]
   [(== ls [res])]
   [(fresh [h t inter]
      (conso h t ls)
      (fd/+ h inter res)
      (magic-sum t inter))]))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn magic [n]
  (let [g     (magic-grid n)
        nums  (range 1 (inc (* n n)))
        ndom  (fd/interval 1 (* n n))
        lsum  (/ (apply + nums) n)
        rows  (partition n g)
        lines (concat
               [(magic-diag n rows)
                (magic-diag n (map reverse rows))]
               rows
               (magic-cols n g))]
    (run* [q]
      (== q g)
      (everyg #(fd/in % ndom) q)
      (distribute q ::l/ff)
      (fd/distinct q)
      (everyg #(magic-sum % lsum) lines))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(comment
  ;; ~420ms
  (dotimes [_ 5]
    (time
     (dotimes [_ 10]
       (doall (take 1 (magic 3))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>  ;; ~670ms
  (dotimes [_ 5]
    (time
     (dotimes [_ 1]
       (doall (take 1 (magic 4)))))))</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.dcg" name="cljs.core.logic.dcg"><h1 class="project-name">cljs.core.logic.dcg</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.dcg
  (:refer-clojure :exclude [==])
  (:require [cljs.core.logic.protocols :as proto :refer [walk]]
            [cljs.core.logic :as l :refer [lvar? ==]]
            [cljs.core :as core]
            [clojure.set :as set]
            [clojure.string :as string])
  (:require-macros [cljs.core.logic.macros
                    :refer [umi uai llist composeg* bind* mplus* -inc
                            conde fresh -run run run* run-db run-db* run-nc
                            run-nc* all is pred project trace-lvars trace-s
                            log ifa* ifu* conda condu lvaro nonlvaro fnm
                            defnm fne defne matche fna fnu defna defnu matcha
                            matchu tabled let-dom fnc defnc in extend-to-fd
                            eq]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare count-clauses)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -&gt;lcons
  ([env [m :as c] i] (-&gt;lcons env c i false))
  ([env [m :as c] i quoted]
     (cond
      (empty? c) `(fresh []
                    (== ~(env (dec i)) ~(env i)))
      :else (let [m (if quoted `(quote ~m) m)]
              `(== ~(env (dec i)) (lcons ~m ~(env i)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lsym [n]
  (gensym (str &quot;l&quot; n &quot;_&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn !dcg? [clause]
  (and (sequential? clause)
       (let [f (first clause)]
         (and (symbol? f)
              (= (name f) &quot;!dcg&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fresh-expr? [clause]
  (and (seq? clause)
       (let [f (first clause)]
         (and (symbol? f)
              (= (name f) &quot;fresh&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn mark-clauses
  ([cs] (mark-clauses cs (atom 0)))
  ([[c &amp; r :as cs] i]
     (cond
      (nil? (seq cs)) ()
      (fresh-expr? c) (cons `(fresh ~(second c)
                               ~@(mark-clauses (drop 2 c) i))
                            (mark-clauses r i))
      (!dcg? c) (cons c (mark-clauses r i))
      :else (cons (with-meta c
                    {:index (swap! i clojure.core/inc)})
                  (mark-clauses r i)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn handle-clauses [env [c &amp; r :as cs]]
  (cond
   (nil? (seq cs)) ()
   (fresh-expr? c) (cons `(fresh ~(second c)
                            ~@(handle-clauses env (drop 2 c)))
                         (handle-clauses env r))
   (!dcg? c) (cons (second c) (handle-clauses env r))
   (vector? c) (cons (-&gt;lcons env c (-&gt; c meta :index))
                     (handle-clauses env r))
   (and (seq? c)
        (= (first c) `quote)
        (vector? (second c))) (cons (-&gt;lcons env (second c) (-&gt; c meta :index) true)
                                    (handle-clauses env r))
        :else (let [i (-&gt; c meta :index)
                    c (if (seq? c) c (list c))]
                (cons (concat c [(env (dec i)) (env i)])
                      (handle-clauses env r)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn handle-cclause [fsym osym cclause]
  (let [c (count-clauses cclause)
        r (range 2 (clojure.core/inc c))
        lsyms (conj (into [fsym] (map lsym r)) osym)
        clauses (mark-clauses cclause)
        clauses (handle-clauses lsyms clauses)]
    `(fresh [~@(butlast (rest lsyms))]
       ~@clauses)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (--&gt;e det
        ('[the])
        ('[a]))
  (--&gt;e n
        ('[witch])
        ('[wizard]))
  (--&gt; v '[curses])
  (--&gt; np det n)
  (--&gt; vp v np)
  (--&gt; s np vp)
  ;; we can stop the dcg transform
  (--&gt; s np (!dcg (== 1 1)) vp)
  ;; success
  (run* [q]
    (np '[the witch] []))
  ;; success
  (run* [q]
    (s '[a witch curses the wizard] []))
  (def--&gt;e verb [v]
    ([[:v 'eats]] '[eats]))
  (def--&gt;e noun [n]
    ([[:n 'bat]] '[bat])
    ([[:n 'cat]] '[cat]))
  (def--&gt;e det [d]
    ([[:d 'the]] '[the])
    ([[:d 'a]] '[a]))
  (def--&gt;e noun-phrase [n]
    ([[:np ?d ?n]] (det ?d) (noun ?n)))
  (def--&gt;e verb-phrase [n]
    ([[:vp ?v ?np]] (verb ?v) (noun-phrase ?np)))
  (def--&gt;e sentence [s]
    ([[:s ?np ?vp]] (noun-phrase ?np) (verb-phrase ?vp)))
  (run 1 [parse-tree]
    (sentence parse-tree '[the bat eats a cat] []))
  ;; ([:s [:np [:d the] [:n bat]] [:vp [:v eats] [:np [:d a] [:n cat]]]])
  ;; ~90-100ms
  (dotimes [_ 10]
    (time
     (dotimes [_ 1e3]
       (run 1 [parse-tree]
         (sentence parse-tree '[the bat eats a cat] [])))))
  ;; parsing lisp
  (def digits (into #{} &quot;1234567890&quot;))
  (defn cr [c1 c2]
    (map char (range (int c1) (int c2))))
  (def alpha (into #{} (concat (cr \a \z) (cr \A \Z))))
  (def alnum (into digits (concat (cr \a \z) (cr \A \Z))))
  (def nonalnum (into #{} &quot;+/-*&gt;&lt;=&quot;))
  (--&gt;e wso
        ([\space] wso)
        ([]))
  (def--&gt;e digito [x]
    ([_] [x]
       (!dcg
        (project [x]
          (== (contains? digits x) true)))))
  (def--&gt;e numo [x]
    ([[?d . ?ds]] (digito ?d) (numo ?ds))
    ([[?d]] (digito ?d)))
  (declare symro)
  (def--&gt;e symo [x]
    ([[?a . ?as]] [?a]
       (!dcg
        (project [?a]
          (conde
           ((== (contains? alpha ?a) true))
           ((== (contains? nonalnum ?a) true)))))
       (symro ?as)))
  (def--&gt;e symro [x]
    ([[?a . ?as]] [?a]
       (!dcg
        (project [?a]
          (conde
           ((== (contains? alnum ?a) true))
           ((== (contains? nonalnum ?a) true)))))
       (symro ?as))
    ([[]] []))
  (declare exprso)
  (def--&gt;e expro [e]
    ([[:sym ?a]] (symo ?a))
    ([[:num ?n]] (numo ?n))
    ([[:list ?list]] [\(] (exprso ?list) [\)])
    ([[:sym :quote ?q]] [\'] (expro ?q)))
  ;; TODO: we need cut here, we found a valid parse
  (def--&gt;e exprso [exs]
    ([[?e . ?es]] wso (expro ?e) wso (exprso ?es))
    ([[]] []))
  ;; (_.0)
  (run* [q]
    (wso (vec &quot;  &quot;) []))
  ;; ()
  (run* [q]
    (wso (vec &quot; f &quot;) []))
  ;; (\1)
  (run* [q]
    (digito q [\1] []))
  ;; ((\1 \2 \3))
  (run* [q]
    (numo q (vec &quot;123&quot;) []))
  ;; ((\a \b \c))
  (run* [q]
    (symo q (vec &quot;abc&quot;) []))
  ;; ([:n (\1 \2 \3)])
  (run* [q]
    (expro q (vec &quot;123&quot;) []))
  ;; ([:s (\a \b \c)])
  (run* [q]
    (expro q (vec &quot;abc&quot;) []))
  ;; (([:list ([:sym (\+)] [:sym (\a \b \c)] [:sym (\b)] [:sym :quote [:list ([:num [\1]] [:num (\2 \3)])]])]))
  (run 1 [q]
    (exprso q (vec &quot; (+ abc b '(1 23))  &quot;) []))
  ;; w/ def--&gt;a ~2500ms
  ;; w/ def--&gt;e ~1400ms
  (dotimes [_ 10]
    (let [s (vec &quot; (+ abc b '(1 23))  &quot;)]
      (time
       (dotimes [_ 50]
         (run 1 [q]
           (exprso q s [])))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.fd" name="cljs.core.logic.fd"><h1 class="project-name">cljs.core.logic.fd</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.fd
  (:refer-clojure :exclude [== &lt; &gt; &lt;= &gt;= + - * quot distinct ISet])
  (:require [cljs.core.logic.protocols :as proto :refer [walk]]
            [cljs.core.logic :as l :refer [lvar?]]
            [clojure.set :as set]
            [clojure.string :as string])
  (:require-macros [cljs.core.logic.macros
                    :refer [umi uai llist composeg* bind* mplus* -inc
                            conde fresh -run run run* run-db run-db* run-nc
                            run-nc* all is pred project trace-lvars trace-s
                            log ifa* ifu* conda condu lvaro nonlvaro fnm
                            defnm fne defne matche fna fnu defna defnu matcha
                            matchu tabled let-dom fnc defnc in extend-to-fd
                            eq]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IInterval
  (-lb [this])
  (-ub [this]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IIntervals
  (-intervals [this]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ISortedDomain
  (-drop-one [this])
  (-drop-before [this n])
  (-keep-before [this n]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ISet
  (-member? [this n])
  (-disjoint? [this that])
  (-intersection [this that])
  (-difference [this that]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare domain sorted-set-&gt;domain
         difference* intersection* disjoint?*
         unify-with-domain* finite-domain?
         interval multi-interval)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bounds [i]
  (l/pair (-lb i) (-ub i)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn interval-&lt; [i j]
  (clojure.core/&lt; (-ub i) (-lb j)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn interval-&lt;= [i j]
  (clojure.core/&lt;= (-ub i) (-lb j)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn interval-&gt; [i j]
  (clojure.core/&gt; (-lb i) (-ub j)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn interval-&gt;= [i j]
  (clojure.core/&gt;= (-lb i) (-ub j)))</pre></td></tr><tr><td class="docs"><h2>FiniteDomain</h2>

<p>wrapper around Clojure sorted sets. Used to represent small
domains. Optimization when interval arithmetic provides little
benefit.</p>

<p>s - a sorted set
min - the minimum value, an optimization
max - the maximum value, an optimization</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype FiniteDomain [s min max]
  IEquiv
  (-equiv [this that]
    (if (finite-domain? that)
      (if (= (proto/-member-count this) (proto/-member-count that))
        (= s (:s that))
        false)
      false))
  ILookup
  (-lookup [this k]
    (-lookup this k nil))
  (-lookup [this k not-found]
    (case k
      :s s
      :min min
      :max max
      not-found))
  proto/IMemberCount
  (-member-count [this] (count s))
  IInterval
  (-lb [_] min)
  (-ub [_] max)
  ISortedDomain
  (-drop-one [_]
    (let [s (disj s min)
          c (count s)]
      (cond
       (= c 1) (first s)
       (clojure.core/&gt; c 1) (FiniteDomain. s (first s) max)
       :else nil)))
  (-drop-before [_ n]
    (apply domain (drop-while #(clojure.core/&lt; % n) s)))
  (-keep-before [this n]
    (apply domain (take-while #(clojure.core/&lt; % n) s)))
  ISet
  (-member? [this n]
    (if (s n) true false))
  (-disjoint? [this that]
    (cond
     (integer? that)
     (if (s that) false true)
     (instance? FiniteDomain that)
     (cond
      (clojure.core/&lt; max (:min that)) true
      (clojure.core/&gt; min (:max that)) true
      :else (empty? (set/intersection s (:s that))))
     :else (disjoint?* this that)))
  (-intersection [this that]
    (cond
     (integer? that)
     (when (-member? this that) that)
     (instance? FiniteDomain that)
     (sorted-set-&gt;domain (set/intersection s (:s that)))
     :else
     (intersection* this that)))
  (-difference [this that]
    (cond
     (integer? that)
     (sorted-set-&gt;domain (disj s that))
     (instance? FiniteDomain that)
     (sorted-set-&gt;domain (set/difference s (:s that)))
     :else
     (difference* this that)))
  IIntervals
  (-intervals [_] (seq s))
  proto/IMergeDomains
  (-merge-doms [this that]
    (-intersection this that))
  IPrintWithWriter
  (-pr-writer [x writer opts]
    (-write writer (str &quot;&lt;domain:&quot; (seq (:s x)) &quot;&gt;&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn finite-domain? [x]
  (instance? FiniteDomain x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sorted-set-&gt;domain [s]
  (let [c (count s)]
    (cond
     (zero? c) nil
     (= c 1) (first s)
     :else (FiniteDomain. s (first s) (first (rseq s))))))</pre></td></tr><tr><td class="docs"><p>Construct a domain for assignment to a var. Arguments should
   be integers given in sorted order. domains may be more efficient
   than intervals when only a few values are possible.</p>
</td><td class="codes"><pre class="brush: clojure">(defn domain
  [&amp; args]
  (when (seq args)
    (sorted-set-&gt;domain (into (sorted-set) args))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare interval?)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-to-fd number)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare interval)</pre></td></tr><tr><td class="docs"><h2>IntervalFD</h2>

<p>Type optimized for interval arithmetic. Only stores bounds.</p>

<p>lb - lower bound
ub - upper bound</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype IntervalFD [lb ub]
  IEquiv
  (-equiv [_ o]
    (if (instance? IntervalFD o)
      (and (= lb (-lb o))
           (= ub (-ub o)))
      false))
  Object
  (toString [this]
    (pr-str this))
  proto/IMemberCount
  (-member-count [this] (inc (clojure.core/- ub lb)))
  IInterval
  (-lb [_] lb)
  (-ub [_] ub)
  ISortedDomain
  (-drop-one [_]
    (let [nlb (inc lb)]
      (when (clojure.core/&lt;= nlb ub)
        (interval nlb ub))))
  (-drop-before [this n]
    (cond
     (= n ub) n
     (clojure.core/&lt; n lb) this
     (clojure.core/&gt; n ub) nil
     :else (interval n ub)))
  (-keep-before [this n]
    (cond
     (clojure.core/&lt;= n lb) nil
     (clojure.core/&gt; n ub) this
     :else (interval lb (dec n))))
  ISet
  (-member? [this n]
    (and (clojure.core/&gt;= n lb) (clojure.core/&lt;= n ub)))
  (-disjoint? [this that]
    (cond
     (integer? that)
     (not (-member? this that))
     (interval? that)
     (let [i this
           j that
           [imin imax] (bounds i)
           [jmin jmax] (bounds j)]
       (or (clojure.core/&gt; imin jmax)
           (clojure.core/&lt; imax jmin)))
     :else (disjoint?* this that)))
  (-intersection [this that]
    (cond
     (integer? that)
     (if (-member? this that)
       that
       nil)
     (interval? that)
     (let [i this j that
           imin (-lb i) imax (-ub i)
           jmin (-lb j) jmax (-ub j)]
       (cond
        (clojure.core/&lt; imax jmin) nil
        (clojure.core/&lt; jmax imin) nil
        (and (clojure.core/&lt;= imin jmin)
             (clojure.core/&gt;= imax jmax)) j
             (and (clojure.core/&lt;= jmin imin)
                  (clojure.core/&gt;= jmax imax)) i
                  (and (clojure.core/&lt;= imin jmin)
                       (clojure.core/&lt;= imax jmax)) (interval jmin imax)
                       (and (clojure.core/&lt;= jmin imin)
                            (clojure.core/&lt;= jmax imax)) (interval imin jmax)
                            :else (throw (ex-info (str &quot;Interval intersection not defined &quot; i &quot; &quot; j) {}))))
     :else (intersection* this that)))
  (-difference [this that]
    (cond
     (integer? that)
     (cond
      (= lb that) (interval (inc lb) ub)
      (= ub that) (interval lb (dec ub))
      :else (if (-member? this that)
              (multi-interval (interval lb (dec that))
                              (interval (inc that) ub))
              this))
     (interval? that)
     (let [i this j that
           imin (-lb i) imax (-ub i)
           jmin (-lb j) jmax (-ub j)]
       (cond
        (clojure.core/&gt; jmin imax) i
        (and (clojure.core/&lt;= jmin imin)
             (clojure.core/&gt;= jmax imax)) nil
             (and (clojure.core/&lt; imin jmin)
                  (clojure.core/&gt; imax jmax))
             (multi-interval (interval imin (dec jmin))
                             (interval (inc jmax) imax))
                  (and (clojure.core/&lt; imin jmin)
                       (clojure.core/&lt;= jmin imax)) (interval imin (dec jmin))
                       (and (clojure.core/&gt; imax jmax)
                            (clojure.core/&lt;= jmin imin)) (interval (inc jmax) imax)
                            :else (throw (ex-info (str &quot;Interval difference not defined &quot; i &quot; &quot; j) {}))))
     :else (difference* this that)))
  IIntervals
  (-intervals [this]
    (list this))
  proto/IMergeDomains
  (-merge-doms [this that]
    (-intersection this that))
  IPrintWithWriter
  (-pr-writer [x writer opts]
    (-write writer (str &quot;&lt;interval:&quot; (-lb x) &quot;..&quot; (-ub x) &quot;&gt;&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn interval? [x]
  (instance? IntervalFD x))</pre></td></tr><tr><td class="docs"><p>Construct an interval for an assignment to a var. intervals may
   be more efficient that the domain type when the range of possiblities
   is large.</p>
</td><td class="codes"><pre class="brush: clojure">(defn interval
  ([ub] (IntervalFD. 0 ub))
  ([lb ub]
     (if (zero? (clojure.core/- ub lb))
       ub
       (IntervalFD. lb ub))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn intersection* [is js]
  (loop [is (seq (-intervals is)) js (seq (-intervals js)) r []]
    (if (and is js)
      (let [i (first is)
            j (first js)]
        (cond
         (interval-&lt; i j) (recur (next is) js r)
         (interval-&gt; i j) (recur is (next js) r)
         :else
         (let [[imin imax] (bounds i)
               [jmin jmax] (bounds j)]
           (cond
            (clojure.core/&lt;= imin jmin)
            (cond
             (clojure.core/&lt; imax jmax)
             (recur (next is)
                    (cons (interval (inc imax) jmax) (next js))
                    (conj r (interval jmin imax)))
             (clojure.core/&gt; imax jmax)
             (recur (cons (interval (inc jmax) imax) (next is))
                    (next js)
                    (conj r j))
             :else
             (recur (next is) (next js)
                    (conj r (interval jmin jmax))))
            (clojure.core/&gt; imin jmin)
            (cond
             (clojure.core/&gt; imax jmax)
             (recur (cons (interval (inc jmax) imax) (next is))
                    (next js)
                    (conj r (interval imin jmax)))
             (clojure.core/&lt; imax jmax)
             (recur is (cons (interval (inc imax) jmax) (next js))
                    (conj r i))
             :else
             (recur (next is) (next js)
                    (conj r (interval imin imax))))))))
      (apply multi-interval r))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn difference* [is js]
  (loop [is (seq (-intervals is)) js (seq (-intervals js)) r []]
    (if is
      (if js
        (let [i (first is)
              j (first js)]
          (cond
           (interval-&lt; i j) (recur (next is) js (conj r i))
           (interval-&gt; i j) (recur is (next js) r)
           :else
           (let [[imin imax] (bounds i)
                 [jmin jmax] (bounds j)]
             (cond
              (clojure.core/&lt; imin jmin)
              (cond
               (clojure.core/&lt; jmax imax)
               (recur (cons (interval (inc jmax) imax) (next is))
                      (next js)
                      (conj r (interval imin (dec jmin))))
               (clojure.core/&gt; jmax imax)
               (recur (next is)
                      (cons (interval (inc imax) jmax) (next js))
                      (conj r (interval imin (dec jmin))))
               :else
               (recur (next is) (next js)
                      (conj r (interval imin (dec jmin)))))
              (clojure.core/&gt;= imin jmin)
              (cond
               (clojure.core/&lt; imax jmax)
               (recur (next is)
                      (cons (interval (inc imax) jmax) (next js))
                      r)
               (clojure.core/&gt; imax jmax)
               (recur (cons (interval (inc jmax) imax) (next is))
                      (next js)
                      r)
               :else (recur (next is) (next js)
                            r))))))
        (apply multi-interval (into r is)))
      (apply multi-interval r))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn disjoint?* [is js]
  (if (-disjoint? (interval (-lb is) (-ub is))
                  (interval (-lb js) (-ub js)))
    true
    (let [d0 (-intervals is)
          d1 (-intervals js)]
      (loop [d0 d0 d1 d1]
        (if (or (nil? d0) (nil? d1))
          true
          (let [i (first d0)
                j (first d1)]
            (cond
             (interval-&lt; i j) (recur (next d0) d1)
             (interval-&gt; i j) (recur d0 (next d1))
             (-disjoint? i j)  (recur (next d0) d1)
             :else false)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare normalize-intervals singleton-dom? multi-interval)</pre></td></tr><tr><td class="docs"><h2>MultiIntervalFD</h2>

<p>Running difference operations on IntervalFD will result in
a series of intervals.</p>

<p>min - minimum value of all contained intervals
max - maximum value of all contained intervals
is  - the intervals</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype MultiIntervalFD [min max is]
  ILookup
  (-lookup [this k]
    (-lookup this k nil))
  (-lookup [this k not-found]
    (case k
      :is is
      :min min
      :max max
      not-found))
  IEquiv
  (-equiv [this j]
    (if (instance? MultiIntervalFD j)
      (let [i this
            [jmin jmax] (bounds j)]
        (if (and (= min jmin) (= max jmax))
          (let [is (normalize-intervals is)
                js (normalize-intervals (-intervals j))]
            (= is js))
          false))
      false))
  proto/IMemberCount
  (-member-count [this]
    (reduce clojure.core/+ 0 (map #(proto/-member-count %) is)))
  IInterval
  (-lb [_] min)
  (-ub [_] max)
  ISortedDomain
  (-drop-one [_]
    (let [i (first is)]
      (if (singleton-dom? i)
        (let [nis (rest is)]
          (MultiIntervalFD. (-lb (first nis)) max nis))
        (let [ni (-drop-one i)]
          (MultiIntervalFD. (-lb ni) max (cons ni (rest is)))))))
  (-drop-before [_ n]
    (let [is (seq is)]
      (loop [is is r []]
        (if is
          (let [i (-drop-before (first is) n)]
            (if i
              (recur (next is) (conj r i))
              (recur (next is) r)))
          (when (pos? (count r))
            (apply multi-interval r))))))
  (-keep-before [_ n]
    (let [is (seq is)]
      (loop [is is r []]
        (if is
          (let [i (-keep-before (first is) n)]
            (if i
              (recur (next is) (conj r i))
              (recur (next is) r)))
          (when (pos? (count r))
            (apply multi-interval r))))))
  ISet
  (-member? [this n]
    (if (some #(-member? % n) is)
      true
      false))
  (-disjoint? [this that]
    (disjoint?* this that))
  (-intersection [this that]
    (intersection* this that))
  (-difference [this that]
    (difference* this that))
  IIntervals
  (-intervals [this]
    (seq is))
  proto/IMergeDomains
  (-merge-doms [this that]
    (-intersection this that))
  IPrintWithWriter
  (-pr-writer [x writer opts]
    (-write writer (str &quot;&lt;intervals:&quot; (apply pr-str (:is x)) &quot;&gt;&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn normalize-intervals [is]
  (reduce (fn [r i]
            (if (zero? (count r))
              (conj r i)
              (let [j (peek r)
                    jmax (-ub j)
                    imin (-lb i)]
                (if (clojure.core/&lt;= (dec imin) jmax)
                  (conj (pop r) (interval (-lb j) (-ub i)))
                  (conj r i)))))
          [] is))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn multi-interval
  ([] nil)
  ([i0] i0)
  ([i0 i1]
     (let [is [i0 i1]]
       (MultiIntervalFD. (reduce min (map -lb is))
                         (reduce max (map -ub is)) is)))
  ([i0 i1 &amp; ir]
     (let [is (into [] (concat (list i0 i1) ir))]
       (MultiIntervalFD. (reduce min (map -lb is))
                         (reduce max (map -ub is)) is))))</pre></td></tr><tr><td class="docs"><p>===========================================================================
CLP(FD)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-dom
  [a x]
  (if (lvar? x)
    (l/get-dom a x :cljs.core.logic/fd)
    x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ext-dom-fd
  [a x dom domp]
  (let [a (l/add-dom a x :cljs.core.logic/fd dom)]
    (if (not= domp dom)
      ((l/run-constraints* [x] (:cs a) :cljs.core.logic/fd) a)
      a)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn singleton-dom? [x]
  (integer? x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn resolve-storable-dom
  [a x dom domp]
  (if (singleton-dom? dom)
    (let [xv (walk a x)]
      (if (lvar? xv)
        (proto/ext-run-cs (l/rem-dom a x :cljs.core.logic/fd) x dom)
        a))
    (ext-dom-fd a x dom domp)))</pre></td></tr><tr><td class="docs"><p>If x is a var we update its domain. If it's an integer
   we check that it's a member of the given domain. dom is
   then new domain, it should have already been calculated from
   domp which was the previous domain.</p>
</td><td class="codes"><pre class="brush: clojure">(defn process-dom
  [x dom domp]
  (fn [a]
    (when dom
      (cond
       (lvar? x) (resolve-storable-dom a x dom domp)
       (-member? dom x) a
       :else nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare domc)</pre></td></tr><tr><td class="docs"><p>Assign a var x a domain.</p>
</td><td class="codes"><pre class="brush: clojure">(defn dom
  [x dom]
  (fn [a]
    (let [domp (get-dom a x)
          dom  (if domp
                 (-intersection dom domp)
                 dom)]
      ((l/composeg
        (process-dom x dom domp)
        (if (and (nil? domp)
                 (not (singleton-dom? dom)))
          (domc x)
          identity)) a))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn map-sum [f]
  (fn loop [ls]
    (if (empty? ls)
      (fn [a] nil)
      (fn [a]
        (proto/mplus
         ((f (first ls)) a)
         (fn []
           ((loop (rest ls)) a)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn to-vals [dom]
  (letfn [(to-vals* [is]
            (when is
              (let [i (first is)]
                (lazy-seq
                 (cons (-lb i)
                       (if-let [ni (-drop-one i)]
                         (to-vals* (cons ni (next is)))
                         (to-vals* (next is))))))))]
    (to-vals* (seq (-intervals dom)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol proto/IForceAnswerTerm
  FiniteDomain
  (-force-ans [v x]
    ((map-sum (fn [n] (l/ext-run-csg x n))) (to-vals v)))

  IntervalFD
  (-force-ans [v x]
    ((map-sum (fn [n] (l/ext-run-csg x n))) (to-vals v)))

  MultiIntervalFD
  (-force-ans [v x]
    ((map-sum (fn [n] (l/ext-run-csg x n))) (to-vals v))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -domc [x]
  (reify
    proto/IEnforceableConstraint
    proto/IConstraintStep
    (-step [this s]
      (let [xv (walk s x)
            xd (-&gt; (proto/root-val s x) :doms :cljs.core.logic/fd)]
        (reify
          IFn
          (-invoke [_ s]
            (if xd
              (when (-member? xd xv)
                (l/rem-dom s x :cljs.core.logic/fd))
              s))
          proto/IEntailed
          (-entailed? [_]
            (nil? xd))
          proto/IRunnable
          (-runnable? [_]
            (not (lvar? xv))))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic.fd/domc)
    (-rands [_] [x])
    proto/IConstraintWatchedStores
    (-watched-stores [this] #{:cljs.core.logic/subst})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn domc [x]
  (l/cgoal (-domc x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ==c [u v]
  (reify
    proto/IEnforceableConstraint
    proto/IConstraintStep
    (-step [this s]
      (let-dom s [u du v dv]
               (reify
                 clojure.core/IFn
                 (-invoke [_ s]
                   (let [i (-intersection du dv)]
                     ((l/composeg
                       (process-dom u i du)
                       (process-dom v i dv)) s)))
                 proto/IEntailed
                 (-entailed? [_]
                   (and (singleton-dom? du)
                        (singleton-dom? dv)
                        (= du dv)))
                 proto/IRunnable
                 (-runnable? [_]
                   (and du dv)))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic.fd/==)
    (-rands [_] [u v])
    proto/IConstraintWatchedStores
    (-watched-stores [this]
      #{:cljs.core.logic/subst :cljs.core.logic/fd})))</pre></td></tr><tr><td class="docs"><p>A finite domain constraint. u and v must be equal. u and v must
   eventually be given domains if vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ==
  [u v]
  (l/cgoal (==c u v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn !=c [u v]
  (reify
    proto/IEnforceableConstraint
    proto/IConstraintStep
    (-step [this s]
      (let-dom s [u du v dv]
               (let [su? (singleton-dom? du)
                     sv? (singleton-dom? dv)]
                 (reify
                   IFn
                   (-invoke [_ s]
                     (cond
                      (and su? sv? (= du dv)) nil
                      (-disjoint? du dv) s
                      su? (when-let [vdiff (-difference dv du)]
                            ((process-dom v vdiff dv) s))
                      :else (when-let [udiff (-difference du dv)]
                              ((process-dom u udiff du) s))))
                   proto/IEntailed
                   (-entailed? [_]
                     (and du dv (-disjoint? du dv)))
                   proto/IRunnable
                   (-runnable? [_]
                     (and du dv (or su? sv?)))))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic.fd/!=)
    (-rands [_] [u v])
    proto/IConstraintWatchedStores
    (-watched-stores [this]
      #{:cljs.core.logic/subst :cljs.core.logic/fd})))</pre></td></tr><tr><td class="docs"><p>A finite domain constraint. u and v must not be equal. u and v
   must eventually be given domains if vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn !=
  [u v]
  (l/cgoal (!=c u v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn &lt;=c [u v]
  (reify
    proto/IEnforceableConstraint
    proto/IConstraintStep
    (-step [this s]
      (let-dom s [u du v dv]
               (reify
                 IFn
                 (-invoke [_ s]
                   (let [umin (-lb du)
                         vmax (-ub dv)]
                     ((composeg*
                       (process-dom u (-keep-before du (inc vmax)) du)
                       (process-dom v (-drop-before dv umin) dv)) s)))
                 proto/IEntailed
                 (-entailed? [_]
                   (and du dv (interval-&lt;= du dv)))
                 proto/IRunnable
                 (-runnable? [_]
                   (and du dv)))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic.fd/&lt;=)
    (-rands [_] [u v])
    proto/IConstraintWatchedStores
    (-watched-stores [this]
      #{:cljs.core.logic/subst :cljs.core.logic/fd})))</pre></td></tr><tr><td class="docs"><p>A finite domain constraint. u must be less than or equal to v.
   u and v must eventually be given domains if vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn &lt;=
  [u v]
  (l/cgoal (&lt;=c u v)))</pre></td></tr><tr><td class="docs"><p>A finite domain constraint. u must be less than v. u and v
   must eventually be given domains if vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn &lt;
  [u v]
  (all
   (&lt;= u v)
   (!= u v)))</pre></td></tr><tr><td class="docs"><p>A finite domain constraint. u must be greater than v. u and v
   must eventually be given domains if vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn &gt;
  [u v]
  (&lt; v u))</pre></td></tr><tr><td class="docs"><p>A finite domain constraint. u must be greater than or equal to v.
   u and v must eventually be given domains if vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn &gt;=
  [u v]
  (&lt;= v u))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn +c [u v w]
  (reify
    proto/IEnforceableConstraint
    proto/IConstraintStep
    (-step [this s]
      (let-dom s [u du v dv w dw]
               (reify
                 IFn
                 (-invoke [_ s]
                   (let [[wmin wmax]
                         (if dw
                           (bounds dw)
                           [(clojure.core/+ (-lb du) (-lb dv))
                            (clojure.core/+ (-ub du) (-ub dv))])
                         [umin umax]
                         (if du
                           (bounds du)
                           [(clojure.core/- (-lb dw) (-ub dv))
                            (clojure.core/- (-ub dw) (-lb dv))])
                         [vmin vmax]
                         (if dv
                           (bounds dv)
                           [(clojure.core/- (-lb dw) (-ub du))
                            (clojure.core/- (-ub dw) (-lb du))])
                         wi (interval (clojure.core/+ umin vmin) (clojure.core/+ umax vmax))
                         ui (interval (clojure.core/- wmin vmax) (clojure.core/- wmax vmin))
                         vi (interval (clojure.core/- wmin umax) (clojure.core/- wmax umin))]
                     (when-let [wi (if (and wi dw) (-intersection wi dw) wi)]
                       (when-let [ui (if (and ui du)
                                       (-intersection ui du)
                                       ui)]
                         (when-let [vi (if (and vi dv)
                                         (-intersection vi dv)
                                         vi)]
                           (when (or (not (every? singleton-dom? [wi ui vi]))
                                     (clojure.core/= (clojure.core/+ ui vi) wi))
                             ((composeg*
                               (process-dom w wi dw)
                               (process-dom u ui du)
                               (process-dom v vi dv))
                              s)))))))
                 proto/IEntailed
                 (-entailed? [_]
                   (and (singleton-dom? du)
                        (singleton-dom? dv)
                        (singleton-dom? dw)
                        (= (clojure.core/+ du dv) dw)))
                 proto/IRunnable
                 (-runnable? [_]
                   (cond
                    du (or dv dw)
                    dv (or du dw)
                    dw (or du dv)
                    :else false)))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic.fd/+)
    (-rands [_] [u v w])
    proto/IConstraintWatchedStores
    (-watched-stores [this]
      #{:cljs.core.logic/subst :cljs.core.logic/fd})))</pre></td></tr><tr><td class="docs"><p>A finite domain constraint for addition and subtraction.
   u, v &amp; w must eventually be given domains if vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn +
  [u v w]
  (l/cgoal (+c u v w)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -
  [u v w]
  (+ v w u))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn *c [u v w]
  (letfn [(safe-div [n c a t]
            (if (zero? n)
              c
              (let [q (clojure.core/quot a n)]
                (case t
                  :lower (if (pos? (rem a n))
                           (inc q)
                           q)
                  :upper q))))]
    (reify
      proto/IEnforceableConstraint
      proto/IConstraintStep
      (-step [this s]
        (let-dom s [u du v dv w dw]
                 (reify
                   IFn
                   (-invoke [_ s]
                     (let [[wmin wmax]
                           (if dw
                             (bounds dw)
                             [(clojure.core/* (-lb du) (-lb dv))
                              (clojure.core/* (-ub du) (-ub dv))])
                           [umin umax]
                           (if du
                             (bounds du)
                             [(safe-div (-ub dv) (-lb dw) (-lb dw) :lower)
                              (safe-div (-lb dv) (-lb dw) (-ub dw) :upper)])
                           [vmin vmax]
                           (if dv
                             (bounds dv)
                             [(safe-div (-ub du) (-lb dw) (-lb dw) :lower)
                              (safe-div (-lb du) (-lb dw) (-ub dw) :upper)])
                           wi (interval (clojure.core/* umin vmin) (clojure.core/* umax vmax))
                           ui (interval (safe-div vmax umin wmin :lower)
                                        (safe-div vmin umax wmax :upper))
                           vi (interval (safe-div umax vmin wmin :lower)
                                        (safe-div umin vmax wmax :upper))]
                       (when-let [wi (if (and wi dw)
                                       (-intersection wi dw)
                                       wi)]
                         (when-let [ui (if (and ui du)
                                         (-intersection ui du)
                                         ui)]
                           (when-let [vi (if (and vi dv)
                                           (-intersection vi dv)
                                           vi)]
                             (when (or (not (every? singleton-dom?
                                                    [wi ui vi]))
                                       (clojure.core/= (clojure.core/* ui vi) wi))
                               ((composeg*
                                 (process-dom w wi dw)
                                 (process-dom u ui du)
                                 (process-dom v vi dv)) s)))))))
                   proto/IEntailed
                   (-entailed? [_]
                     (and (singleton-dom? du)
                          (singleton-dom? dv)
                          (singleton-dom? dw)
                          (= (clojure.core/* du dv) dw)))
                   proto/IRunnable
                   (-runnable? [_]
                     (cond
                      du (or dv dw)
                      dv (or du dw)
                      dw (or du dv)
                      :else false)))))
      proto/IConstraintOp
      (-rator [_] `cljs.core.logic.fd/*)
      (-rands [_] [u v w])
      proto/IConstraintWatchedStores
      (-watched-stores [this]
        #{:cljs.core.logic/subst :cljs.core.logic/fd}))))</pre></td></tr><tr><td class="docs"><p>A finite domain constraint for multiplication and
   thus division. u, v &amp; w must be eventually be given
   domains if vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn *
  [u v w]
  (l/cgoal (*c u v w)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn quot [u v w]
  (* v w u))</pre></td></tr><tr><td class="docs"><p>The real <em>individual</em> distinct constraint. x is a var that now is bound to
   a single value. y* were the non-singleton bound vars that existed at the
   construction of the constraint. n* is the set of singleton domain values
   that existed at the construction of the constraint. We use categorize to
   determine the current non-singleton bound vars and singleton vlaues. if x
   is in n* or the new singletons we have failed. If not we simply remove
   the value of x from the remaining non-singleton domains bound to vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn -distinctc
  [x y* n*]
  (reify
    proto/IEnforceableConstraint
    proto/IConstraintStep
    (-step [this s]
      (let [x (walk s x)]
        (reify
          IFn
          (-invoke [_ s]
            (when-not (n* x)
              (loop [y* (seq y*) s s]
                (if y*
                  (let [y (first y*)
                        v (or (get-dom s y) (walk s y))
                        s (if-not (lvar? v)
                            (cond
                             (= x v) nil
                             (-member? v x)
                             ((process-dom y (-difference v x) v) s)
                             :else s)
                            s)]
                    (when s
                      (recur (next y*) s)))
                  ((l/remcg this) s)))))
          proto/IRunnable
          (-runnable? [_]
            (singleton-dom? x)))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic.fd/-distinct)
    (-rands [_] [x])
    proto/IConstraintWatchedStores
    (-watched-stores [this] #{:cljs.core.logic/subst})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -distinct [x y* n*]
  (l/cgoal (-distinctc x y* n*)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn list-sorted? [pred ls]
  (if (empty? ls)
    true
    (loop [f (first ls) ls (next ls)]
      (if ls
        (let [s (first ls)]
          (if (pred f s)
            (recur s (next ls))
            false))
        true))))</pre></td></tr><tr><td class="docs"><p>The real distinct constraint. v* can be seq of logic vars and
   values or it can be a logic var itself. This constraint does not
   run until v* has become ground. When it has become ground we group
   v* into a set of logic vars and a sorted set of known singleton
   values. We then construct the individual constraint for each var.</p>
</td><td class="codes"><pre class="brush: clojure">(defn distinctc
  [v*]
  (reify
    proto/IEnforceableConstraint
    proto/IConstraintStep
    (-step [this s]
      (let [v* (walk s v*)]
        (reify
          IFn
          (-invoke [_ s]
            (let [{x* true n* false} (group-by lvar? v*)
                  n* (sort clojure.core/&lt; n*)]
              (when (list-sorted? clojure.core/&lt; n*)
                (let [x* (into #{} x*)
                      n* (into (sorted-set) n*)]
                  (loop [xs (seq x*) s s]
                    (if xs
                      (let [x (first xs)]
                        (when-let [s ((-distinct x (disj x* x) n*) s)]
                          (recur (next xs) s)))
                      ((l/remcg this) s)))))))
          proto/IRunnable
          (-runnable? [_]
            (not (l/lvar? v*))))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic.fd/distinct)
    (-rands [_] [v*])
    proto/IConstraintWatchedStores
    (-watched-stores [this] #{:cljs.core.logic/subst})))</pre></td></tr><tr><td class="docs"><p>A finite domain constraint that will guarantee that
   all vars that occur in v* will be unified with unique
   values. v* need not be ground. Any vars in v* should
   eventually be given a domain.</p>
</td><td class="codes"><pre class="brush: clojure">(defn distinct
  [v*]
  (l/cgoal (distinctc v*)))</pre></td></tr><tr><td class="docs"><p>Ensure that the list l never grows beyond bound n.
   n must have been assigned a domain.</p>
</td><td class="codes"><pre class="brush: clojure">(defne bounded-listo
  [l n]
  ([() _] (&lt;= 0 n))
  ([[h . t] n]
     (fresh [m]
       (in m (interval 0 js/Number.MAX_VALUE))
       (+ m 1 n)
       (bounded-listo t m))))</pre></td></tr><tr><td class="docs"><p><hr />
FD Equation Sugar</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def binops-&gt;fd
  '{+  cljs.core.logic.fd/+
    -  cljs.core.logic.fd/-
    *  cljs.core.logic.fd/*
    /  cljs.core.logic.fd/quot
    =  cljs.core.logic.fd/==
    != cljs.core.logic.fd/!=
    &lt;= cljs.core.logic.fd/&lt;=
    &lt;  cljs.core.logic.fd/&lt;
    &gt;= cljs.core.logic.fd/&gt;=
    &gt;  cljs.core.logic.fd/&gt;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def binops (set (keys binops-&gt;fd)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn expand [form]
  (if (seq? form)
    (let [[op &amp; args] form]
      (if (and (binops op) (clojure.core/&gt; (count args) 2))
        (list op (expand (first args))
              (expand (cons op (rest args))))
        (cons op (map expand args))))
    form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn eq*
  ([form vars] (eq* form vars nil))
  ([form vars out]
     (if (seq? form)
       (let [[op r1 r2] form
             [outl outlv?] (if (seq? r1)
                             (let [s (gensym)]
                               (swap! vars conj s)
                               [s true])
                             [r1 false])
             [outr outrv?] (if (seq? r2)
                             (let [s (gensym)]
                               (swap! vars conj s)
                               [s true])
                             [r2 false])
             op (binops-&gt;fd op)]
         (cons (if out
                 (list op outl outr out)
                 (list op outl outr))
               (concat (when (seq? r1)
                         (eq* r1 vars (when outlv? outl)))
                       (when (seq? r2)
                         (eq* r2 vars (when outrv? outr))))))
       form)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -&gt;fd [vars exprs]
  `(fresh [~@vars]
     ~@(reverse exprs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn eq-form [form]
  (let [vars (atom [])
        exprs (eq* (expand form) vars)]
    (-&gt;fd @vars exprs)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.nominal" name="cljs.core.logic.nominal"><h1 class="project-name">cljs.core.logic.nominal</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.nominal
  (:refer-clojure :exclude [== hash -hash])
  (:require [cljs.core.logic :as l
             :refer [empty-s lcons lvar to-s == reify-lvar-name fail succeed
                     walk* conso s# u# != copy-term rembero membero member1o
                     emptyo resto firsto appendo reifyg partial-map predc
                     featurec everyg composeg solutions pair ext-run-csg
                     run-constraints* addcg make-cs var-rands force-ans
                     verify-all-bound enforce-constraints add-attr entangle
                     !=c nafc treec -reify tree-term? distribute rem-attr
                     get-attr distincto cgoal lvar? remcg constrain-tree ext
                     subst-val? unify occurs-check -reify*]]
            [cljs.core.logic.protocols :as proto
             :refer [walk ifa -step -rator addc -entailed? -runnable? id
                     constraints-for take* root-var root-val -prefix
                     -with-prefix tree-constraint? with-id remc
                     -constrain-tree ext-run-cs ext-no-check walk-term]]
            [cljs.core :as core])
  (:require-macros [cljs.core.logic.macros
                    :refer [umi uai llist composeg* bind* mplus* -inc
                            conde fresh -run run run* run-db run-db* run-nc
                            run-nc* all is pred project trace-lvars trace-s
                            log ifa* ifu* conda condu lvaro nonlvaro fnm
                            defnm fne defne matche fna fnu defna defnu matcha
                            matchu tabled let-dom fnc defnc]]))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Nominal unification with fresh, hash and tie.</p>

<p>Some references / inspiration:
alphaKanren - http://www.cs.indiana.edu/~webyrd/alphamk/alphamk.pdf
Nominal Unification - http://www.cl.cam.ac.uk/~amp12/papers/nomu/nomu-jv.pdf
http://code.google.com/p/iucs-relational-research/source/browse/trunk/lib/minikanren/nominal.sls</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>===========================================================================
Nominal unification protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol INomSwap
  (swap-noms [t swap s]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn nom-swap [a swap]
  (cond
   (= a (first swap)) (second swap)
   (= a (second swap)) (first swap)
   :else a))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare suspc)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol INomSwap
  nil
  (swap-noms [t swap s] [t s])

  default
  (swap-noms [t swap s]
    (cond (coll? t)
          (if (seq t)
            (let [[tfirst s] (swap-noms (first t) swap s)
                  [tnext s] (swap-noms (next t) swap s)]
              [(with-meta (cons tfirst tnext) (meta t)) s])
            [t s])
          (map? t)
          (let [[tkvs s] (swap-noms (seq t) swap s)]
            [(into {} tkvs) s])
          :else [t s]))

  l/LVar
  (swap-noms [t swap s]
    (let [t (walk s t)]
      (if (lvar? t)
        (let [v (with-meta (lvar) (meta t))
              rt (root-val s t)
              s (-&gt; (if (subst-val? rt) (ext-no-check s v rt) s)
                    (entangle t v)
                    ((suspc v t swap)))]
          [v s])
        (swap-noms t swap s))))

  l/LCons
  (swap-noms [t swap s]
    (let [[tfirst s] (swap-noms (proto/lfirst t) swap s)
          [tnext s] (swap-noms (proto/lnext t) swap s)]
      [(with-meta (lcons tfirst tnext) (meta t))
       s]))

  PersistentVector
  (swap-noms [t swap s]
    (let [[ts s] (swap-noms (seq t) swap s)]
      [(vec ts) s])))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Nom</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare nom)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype Nom [lvar]
  proto/IBindable
  Object
  (toString [_]
    (str &quot;&lt;nom:&quot; (:name lvar) &quot;&gt;&quot;))
  IHash
  (cljs.core/-hash [_] (cljs.core/hash lvar))
  IEquiv
  (-equiv [this o]
    (and (instance? Nom o)
         (= lvar (:lvar o))))
  IMeta
  (-meta [this] (meta lvar))
  IWithMeta
  (-with-meta [this new-meta]
    (nom (with-meta lvar new-meta)))
  ILookup
  (-lookup [this k]
    (-lookup this k nil))
  (-lookup [_ k not-found]
    (case k
      :lvar lvar
      :name (:name lvar)
      :oname (:oname lvar)
      not-found))
  proto/IReifyTerm
  (reify-term [v s]
    (ext s v (symbol (str (if (-&gt; s meta (:reify-noms true))
                            &quot;a&quot;
                            (:oname v)) &quot;_&quot; (count s)))))
  INomSwap
  (swap-noms [t swap s]
    [(nom-swap t swap) s])
  IPrintWithWriter
  (-pr-writer [x writer opts]
    (-write writer (str &quot;&lt;nom:&quot; (:name x) &quot;&gt;&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn nom [lvar]
  (Nom. lvar))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn nom? [x]
  (instance? Nom x))</pre></td></tr><tr><td class="docs"><p>===========================================================================
hash: ensure a nom is free in a term</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare tie? hash)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- -hash [a x]
  (reify
    Object
    (toString [_]
      (str a &quot;#&quot; x))
    proto/IConstraintStep
    (-step [this s]
      (let [a (walk s a)
            x (walk s x)]
        (reify
          IFn
          (-invoke [_ s]
            ((composeg*
              (remcg this)
              (fn [s]
                (cond
                 (and (lvar? a) (lvar? x) (= x a)) nil
                 (and (nom? a) (nom? x) (= x a)) nil
                 (and (not (lvar? a)) (not (nom? a))) nil
                 (and (nom? a) (tie? x) (= (:binding-nom x) a)) s
                 (and (tree-term? x)
                      (or (not (tie? x)) (nom? a)))
                 ((constrain-tree x
                                  (fn [t s] ((hash a t) s))) s)
                 :else s))) s))
          proto/IRunnable
          (-runnable? [_]
            (if (lvar? a)
              (or (and (lvar? x) (= x a))
                  (and (tree-term? x) (not (tie? x))))
              (or (not (nom? a))
                  (not (lvar? x))))))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic.nominal/hash)
    (-rands [_] [a x])
    proto/IReifiableConstraint
    (-reifyc [_ v r s]
      (let [x (walk* r (walk* s x))
            a (walk* r (walk* s a))]
        ;; Filter constraints unrelated to reified variables.
        (when (and (symbol? a) (empty? (-&gt;&gt; (list x) flatten (filter lvar?))))
          (symbol (str a &quot;#&quot; x)))))
    proto/IConstraintWatchedStores
    (-watched-stores [this] #{::l/subst})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn hash [a t]
  (cgoal (-hash a t)))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Suspensions as constraints</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- -do-suspc [t1 t2 swap a]
  (let [x (loop [vs #{t2} seen #{}]
            (let [vs (clojure.set/difference vs seen)]
              (cond
               (empty? vs) true
               (some #(occurs-check a % t1) vs) false
               :else (recur
                      (reduce
                       (fn [s0 s1]
                         (clojure.set/union s0 (:eset (root-val a s1))))
                       #{} vs)
                      (clojure.set/union vs seen)))))]
    (when x
      (let [[t1 a] (swap-noms t1 swap a)]
        ((== t1 t2) a)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -suspc [v1 v2 swap]
  (reify
    Object
    (toString [_]
      (str &quot;suspc&quot; v1 v2 swap))
    proto/IConstraintStep
    (-step [this a]
      (let [t1 (walk a v1)
            t2 (walk a v2)]
        (reify
          IFn
          (-invoke [_ a]
            ((composeg*
              (remcg this)
              (fn [a]
                (cond
                 (not (lvar? t1)) (-do-suspc t1 t2 swap a)
                 (not (lvar? t2)) (-do-suspc t2 t1 swap a)
                 :else ;; (= t1 t2)
                 (loop [a* swap a a]
                   (if (empty? a*) a
                       (recur (rest a*) ((hash (first a*) t2) a))))))) a))
          proto/IRunnable
          (-runnable? [_]
            (or (not (lvar? t1)) (not (lvar? t2)) (= t1 t2))))))
    proto/IConstraintOp
    (-rator [_] `cljs.core.logic.nominal/suspc)
    (-rands [_] [v1 v2])
    proto/IReifiableConstraint
    (-reifyc [c v r a]
      (let [t1 (walk* r (walk* a v1))
            t2 (walk* r (walk* a v2))
            swap (walk* r swap)]
        (when (and
               (not (lvar? t1))
               (not (lvar? t2))
               (symbol? (first swap))
               (symbol? (second swap)))
          `(~'swap ~swap ~t1 ~t2))))
    proto/IConstraintWatchedStores
    (-watched-stores [this] #{::l/subst})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn suspc [v1 v2 swap]
  (cgoal (-suspc v1 v2 swap)))</pre></td></tr><tr><td class="docs"><p>===========================================================================
tie: bind a nom in a term</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare tie)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Tie [binding-nom body]
  proto/ITreeTerm
  proto/IUnifyTerms
  (unify-terms [v u s]
    (cond
     (tie? u)
     (if (= (:binding-nom v) (:binding-nom u))
       (unify s (:body v) (:body u))
       (let [[t s]
             (swap-noms (:body v) [(:binding-nom v) (:binding-nom u)] s)]
         ((composeg*
           (hash (:binding-nom u) (:body v))
           (== t (:body u))) s)))
     :else nil))
  proto/IReifyTerm
  (reify-term [v s]
    (let [s (-reify* s binding-nom)]
      (let [s (-reify* s body)]
        s)))
  proto/IWalkTerm
  (walk-term [v f]
    (with-meta
      (tie (walk-term (:binding-nom v) f)
           (walk-term (:body v) f))
      (meta v)))
  proto/IOccursCheckTerm
  (occurs-check-term [v x s]
    (occurs-check s x (:body v)))
  proto/IConstrainTree
  (-constrain-tree [t fc s]
    (fc (:body t) s))
  proto/IForceAnswerTerm
  (-force-ans [v x]
    (force-ans (:body v)))
  INomSwap
  (swap-noms [t swap s]
    (let [[tbody s] (swap-noms (:body t) swap s)]
      [(with-meta (tie (nom-swap (:binding-nom t) swap) tbody) (meta t)) s]))
  IPrintWithWriter
  (-pr-writer [x writer opts]
    (-write writer &quot;[&quot;)
    (pr-writer (:binding-nom x) writer opts)
    (-write writer &quot;] &quot;)
    (pr-writer (:body x) writer opts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn tie [binding-nom body]
  (Tie. binding-nom body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn tie? [x]
  (instance? Tie x))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.pldb" name="cljs.core.logic.pldb"><h1 class="project-name">cljs.core.logic.pldb</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.pldb
  (:refer-clojure :exclude [indexed? ==])
  (:require [cljs.core.logic :as l :refer [==]])
  (:require-macros [cljs.core.logic.macros
                    :refer [umi uai llist composeg* bind* mplus* -inc
                            conde fresh -run run run* run-db run-db* run-nc
                            run-nc* all is pred project trace-lvars trace-s
                            log ifa* ifu* conda condu lvaro nonlvaro fnm
                            defnm fne defne matche fna fnu defna defnu matcha
                            matchu tabled let-dom fnc defnc with-db with-dbs
                            db-rel]]))</pre></td></tr><tr><td class="docs"><hr />
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def empty-db {})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn facts-for [dbs kname]
  (mapcat #(get-in % [kname ::unindexed]) dbs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn facts-using-index [dbs kname index val]
  (mapcat #(get-in % [kname index val]) dbs))</pre></td></tr><tr><td class="docs"><h2></h2>
</td><td class="codes"><pre class="brush: clojure">(defn rel-key [rel]
  (if (keyword? rel)
    rel
    (:rel-name (meta rel))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rel-indexes [rel]
  (:indexes (meta rel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn indexed? [v]
  (true? (:index (meta v))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn contains-lvar? [x]
  (some l/lvar? (tree-seq coll? seq x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ground? [s term]
  (not (contains-lvar? (l/walk* s term))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn index-for-query [s q indexes]
  (let [indexable (map #(ground? s %)  q)
        triples (map vector (range) indexable indexes)]
    (first (for [[i indexable indexed] triples
                 :when (and indexable indexed)]
             i))))</pre></td></tr><tr><td class="docs"><hr />
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn db-fact [db rel &amp; args]
  (let [key
        (rel-key rel)
        add-to-set
        (fn [current new]
          (conj (or current #{}) new))
        db-with-fact
        (update-in db [key ::unindexed] #(add-to-set %1 args))
        indexes-to-update
        (map vector (rel-indexes rel) (range) args)
        update-index-fn
        (fn [db [is-indexed index-num val]]
          (if is-indexed
            (update-in db [key index-num val] #(add-to-set %1 args))
            db))]
    (reduce update-index-fn db-with-fact indexes-to-update)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn db-retraction [db rel &amp; args]
  (let [key
        (rel-key rel)
        retract-args
        #(disj %1 args)
        db-without-fact
        (update-in db [key ::unindexed] retract-args)
        indexes-to-update ;; also a bit ugly
        (map vector (rel-indexes rel) (range) args)
        remove-from-index-fn
        (fn [db [is-indexed index-num val]]
          (if is-indexed
            (update-in db [key index-num val] retract-args)
            db))]
    (reduce remove-from-index-fn db-without-fact indexes-to-update)))</pre></td></tr><tr><td class="docs"><h2></h2>
</td><td class="codes"><pre class="brush: clojure">(defn db-facts [base-db &amp; facts]
  (reduce #(apply db-fact %1 %2) base-db facts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn db [&amp; facts]
  (apply db-facts empty-db facts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn db-retractions [base-db &amp; retractions]
  (reduce #(apply db-retraction %1 %2) base-db retractions))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (db-rel orbits orbital body)
  (db-rel stars star)
  (def facts
    (db [orbits :mercury :sun]
        [orbits :venus :sun]
        [orbits :earth :sun]
        [orbits :mars :sun]
        [orbits :jupiter :sun]
        [orbits :saturn :sun]
        [orbits :uranus :sun]
        [orbits :neptune :sun]
        [stars :sun]
        [stars :alpha-centauri]
        [orbits :Bb :alpha-centauri]
        [orbits :moon :earth]))
  (with-db facts
    (doall (run* [q]
             (fresh [orbital body]
               (orbits orbital body)
               (== q orbital)))))
  (defn planeto
    [body]
    (fresh [star]
      (stars star)
      (orbits body star)))
  (with-db facts
    (run* [q]
      (planeto :earth)))
  (with-db facts
    (run* [q]
      (planeto :earth)
      (== q true)))
  (with-db facts
    (run* [q]
      (planeto :sun)
      (== q true)))
  (with-db facts
    (run* [q]
      (fresh [orbital]
        (planeto orbital)
        (== q orbital))))
  (with-db facts
    (run* [q]
      (planeto :Bb)))
  (defn satelliteo
    [body]
    (fresh [p]
      (orbits body p)
      (planeto p)))
  (with-db facts
    (run* [q]
      (satelliteo :sun)))
  (with-db facts
    (run* [q]
      (satelliteo :earth)))
  (with-db facts
    (run* [q]
      (satelliteo :moon))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.pprint" name="cljs.core.logic.pprint"><h1 class="project-name">cljs.core.logic.pprint</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.pprint
  (:require [goog.string :as gstring])
  (:import [goog.string StringBuffer]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IPrettyPrintWithWriter
  (-ppr-writer [object writer opts]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -pprint
  [objects writer]
  (pr-with-opts objects writer writer (assoc (pr-opts) :readably false)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pprint
  [&amp; objects]
  (-pprint objects (StringBufferWriter. (StringBuffer.))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.protocols" name="cljs.core.logic.protocols"><h1 class="project-name">cljs.core.logic.protocols</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.protocols)</pre></td></tr><tr><td class="docs"><p>Marker Interfaces</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IBindable)
(defprotocol ITreeTerm)
(defprotocol IVar)</pre></td></tr><tr><td class="docs"><p>Utility Protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IUninitialized
  (-uninitialized [coll]))</pre></td></tr><tr><td class="docs"><p>Unification protocols for core Clojure types</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IUnifyTerms
  (unify-terms [u v s]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IUnifyWithRecord
  (unify-with-record [u v s]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol INonStorable)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean non-storable? [x]
  (satisfies? INonStorable x))</pre></td></tr><tr><td class="docs"><p>Utility Protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol LConsSeq
  (lfirst [this])
  (lnext [this]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol LConsPrint
  (toShortString [this]))</pre></td></tr><tr><td class="docs"><p>Substitution</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ISubstitutions
  (ext-no-check [this x v])
  (walk [this x]))</pre></td></tr><tr><td class="docs"><p>Protocols for terms</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IReifyTerm
  (reify-term [v s]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IWalkTerm
  (walk-term [v f]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IOccursCheckTerm
  (occurs-check-term [v x s]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IBuildTerm
  (build-term [u s]))</pre></td></tr><tr><td class="docs"><p>Goal protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IBind
  (bind [this g]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IMPlus
  (mplus [a f]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ITake
  (take* [a]))</pre></td></tr><tr><td class="docs"><p>Soft cut &amp; committed choice protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IIfA
  (ifa [b gs c]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IIfU
  (ifu [b gs c]))</pre></td></tr><tr><td class="docs"><p>Rel protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IRel
  (setfn [this arity f])
  (indexes-for [this arity])
  (add-indexes [this arity index]))</pre></td></tr><tr><td class="docs"><p>Tabling Protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ITabled
  (-reify-tabled [this v])
  (reify-tabled [this v])
  (reuse [this argv cache start end])
  (subunify [this arg ans]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ISuspendedStream
  (ready? [this]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IAnswerCache
  (-add [this x])
  (-cached? [this x]))</pre></td></tr><tr><td class="docs"><p>cKanren protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ISubstitutionsCLP
  (root-val [this x])
  (root-var [this x])
  (ext-run-cs [this x v])
  (queue [this c])
  (update-var [this x v]))</pre></td></tr><tr><td class="docs"><p>Constraint store</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IConstraintStore
  (addc [this a c])
  (updatec [this a c])
  (remc [this a c])
  (runc [this c state])
  (constraints-for [this a x ws])
  (migrate [this x root]))</pre></td></tr><tr><td class="docs"><p>Generic constraint Protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IConstraintStep
  (-step [c s]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IRunnable
  (-runnable? [c]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IEntailed
  (-entailed? [c]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IEntailedVar
  (-entailed-var? [c x]))</pre></td></tr><tr><td class="docs"><p>Constraint reflection protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IWithConstraintId
  (-with-id [c id]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IConstraintId
  (-id [c]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn id [c]
  (if (satisfies? IConstraintId c)
    (-id c)
    (-&gt; c meta ::id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn with-id [c id]
  (if (satisfies? IWithConstraintId c)
    (-with-id c id)
    (vary-meta c assoc ::id id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IConstraintWatchedStores
  (-watched-stores [c]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IConstraintOp
  (-rator [c])
  (-rands [c]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IReifiableConstraint
  (-reifyc [c v r a]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean reifiable? [x]
  (satisfies? IReifiableConstraint x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IEnforceableConstraint)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean enforceable? [x]
  (satisfies? IEnforceableConstraint x))</pre></td></tr><tr><td class="docs"><p>cgoal</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IUnwrapConstraint
  (-unwrap [c]))</pre></td></tr><tr><td class="docs"><p>generic domain related protocols</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IMergeDomains
  (-merge-doms [a b]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IMemberCount
  (-member-count [dom]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IForceAnswerTerm
  (-force-ans [v x]))</pre></td></tr><tr><td class="docs"><p>Tree Constraints</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IDisunifyTerms
  (-disunify-terms [u v s cs]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ITreeConstraint)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^boolean tree-constraint? [x]
  (satisfies? ITreeConstraint x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IPrefix
  (-prefix [c]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IWithPrefix
  (-with-prefix [c p]))</pre></td></tr><tr><td class="docs"><p>Partial Maps</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IUnifyWithPMap
  (unify-with-pmap [pmap u s]))</pre></td></tr><tr><td class="docs"><p>Deep Constraints</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IConstrainTree
  (-constrain-tree [t fc s]))</pre></td></tr><tr><td class="docs"><p>Features</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IFeature
  (-feature [x]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cljs.core.logic.unifier" name="cljs.core.logic.unifier"><h1 class="project-name">cljs.core.logic.unifier</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cljs.core.logic.unifier
  (:refer-clojure :exclude [==])
  (:require [cljs.core.logic.protocols :as proto
             :refer [queue walk-term take* -unwrap walk]]
            [cljs.core.logic :as l :refer [lcons reifyg fix-constraints
                                           empty-s -reify ==]])
  (:require-macros [cljs.core.logic.macros
                    :refer [umi uai llist composeg* bind* mplus* -inc
                            conde fresh -run run run* run-db run-db* run-nc
                            run-nc* all is pred project trace-lvars trace-s
                            log ifa* ifu* conda condu lvaro nonlvaro fnm
                            defnm fne defne matche fna fnu defna defnu matcha
                            matchu tabled let-dom fnc defnc]]))</pre></td></tr><tr><td class="docs"><p>===========================================================================
Easy Unification</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- lvarq-sym? [s]
  (and (symbol? s) (= (first (str s)) \?)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- proc-lvar [lvar-expr store]
  (let [v (if-let [u (@store lvar-expr)]
            u
            (l/lvar lvar-expr false))]
    (swap! store assoc lvar-expr v)
    v))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- lcons-expr? [expr]
  (and (seq? expr) (some '#{.} (set expr))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare prep*)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- replace-lvar [store]
  (fn [expr]
    (if (lvarq-sym? expr)
      (proc-lvar expr store)
      (if (lcons-expr? expr)
        (prep* expr store)
        expr))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- prep*
  ([expr store] (prep* expr store false false))
  ([expr store lcons?] (prep* expr store lcons? false))
  ([expr store lcons? last?]
     (let [expr (if (and last? (seq expr))
                  (first expr)
                  expr)]
       (cond
        (lvarq-sym? expr)
        (proc-lvar expr store)
        (seq? expr)
        (if (or lcons? (lcons-expr? expr))
          (let [[f &amp; n] expr
                skip (= f '.)
                tail (prep* n store lcons? skip)]
            (if skip
              tail
              (lcons (prep* f store) tail)))
          (walk-term expr (replace-lvar store)))
        :else expr))))</pre></td></tr><tr><td class="docs"><p>Prep a quoted expression. All symbols preceded by ? will
  be replaced with logic vars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn prep
  [expr]
  (let [lvars (atom {})
        prepped (cond
                 (lvarq-sym? expr) (proc-lvar expr lvars)
                 (lcons-expr? expr)
                 (prep* expr lvars true)
                 :else (walk-term expr (replace-lvar lvars)))]
    (if (satisfies? cljs.core/IMeta prepped)
      (with-meta prepped {::lvars (keys @lvars)})
      prepped)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn queue-constraint [s c vs]
  (cond
   (vector? vs)
   (queue s (-unwrap (apply c (map #(l/lvar % false) vs))))
   (set? vs)
   (reduce (fn [s v] (queue s (-unwrap (c (l/lvar v false))))) s vs)
   (symbol? vs)
   (queue s (-unwrap (apply c (map #(l/lvar % false) (list vs)))))
   :else
   (throw
    (ex-info
     (str &quot;Only symbol, set of symbols, or vector of symbols allowed &quot;
          &quot;on left hand side&quot;) {}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn queue-constraints [s [vs cs]]
  (let [cs (if-not (sequential? cs) [cs] cs)]
    (reduce (fn [s c] (queue-constraint s c vs)) s cs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -unify* [init-s u w]
  (first
   (take*
    (fn []
      ((fresh [q]
         (== u w)
         (== q u)
         (fn [a] (fix-constraints a))
         (reifyg q))
       init-s)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn init-s [opts s]
  (let [s (reduce (fn [s [k v]] ((== k v) s)) s (:as opts))]
    (reduce queue-constraints
            (with-meta s {:reify-vars (fn [v rs] rs)})
            (:when opts))))</pre></td></tr><tr><td class="docs"><p>Unify the terms ts.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unify*
  ([ts] (unify* {} ts))
  ([opts ts]
     (let [init-s (init-s opts empty-s)]       
       (-unify*
        (vary-meta init-s assoc :reify-vars false)
        (reduce #(-unify* init-s %1 %2) (butlast ts))
        (last ts)))))</pre></td></tr><tr><td class="docs"><p>Return the unifier that unifies terms ts.
  All terms in ts should prepped terms.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unifier*
  ([ts] (unifier* {} ts))
  ([opts ts]
     (letfn [(-unifier* [s u w]
               (let [s (fix-constraints
                        (l/unify (with-meta s {:reify-vars false}) u w))]
                 (when s
                   (-&gt;&gt; (:lvars opts)
                        (map (fn [sym] [sym (l/lvar sym false)]))
                        (filter (fn [[sym var]] (not= (walk s var) var)))
                        (map (fn [[sym var]] [sym (-reify s var)]))
                        (into {})))))]
       (let [init-s (init-s opts empty-s)]
         (reduce #(-unifier* init-s %1 %2) ts)))))</pre></td></tr><tr><td class="docs"><p>Unify the terms ts returning a the value that represents their
   unificaiton. Will prep the terms.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unify
  ([ts] (unify {} ts))
  ([opts ts]
     (let [opts (if (contains? opts :as)
                  (assoc opts :as
                         (-&gt;&gt; (:as opts)
                              (map (fn [[k v]] [(l/lvar k false) (prep v)]))
                              (into {})))
                  opts)]
       (unify* opts (map prep ts)))))</pre></td></tr><tr><td class="docs"><p>Return the unifier for terms ts. Will prep the terms.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unifier
  ([ts] (unifier {} ts))
  ([opts ts]
     (let [opts (if (contains? opts :as)
                  (assoc opts :as
                         (-&gt;&gt; (:as opts)
                              (map (fn [[k v]] [(l/lvar k false) (prep v)]))
                              (into {})))
                  opts)
           ts' (map prep ts)
           lvars (-&gt;&gt; (concat ts' (map val (:as opts)))
                      (map #(-&gt; % meta ::lvars))
                      (reduce into))]
       (unifier* (assoc opts :lvars lvars) (map prep ts)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/fogus/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
       SyntaxHighlighter.all()</script></body></html>